<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Neighborhoods, structuring elements, and kernels · LocalFilters.jl Package</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LocalFilters.jl Package</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../generic/">Generic local filters</a></li><li class="is-active"><a class="tocitem" href>Neighborhoods, structuring elements, and kernels</a><ul class="internal"><li><a class="tocitem" href="#Neighborhoods-and-structuring-elements"><span>Neighborhoods and structuring elements</span></a></li><li><a class="tocitem" href="#Kernels"><span>Kernels</span></a></li></ul></li><li><a class="tocitem" href="../linear/">Linear filters</a></li><li><a class="tocitem" href="../nonlinear/">Non-linear filters</a></li><li><a class="tocitem" href="../morphology/">Non-linear morphological filters</a></li><li><a class="tocitem" href="../separable/">Efficient separable filters for associative operations</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Neighborhoods, structuring elements, and kernels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Neighborhoods, structuring elements, and kernels</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LocalFilters.jl/blob/master/docs/src/neighborhoods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Neighborhoods,-structuring-elements,-and-kernels"><a class="docs-heading-anchor" href="#Neighborhoods,-structuring-elements,-and-kernels">Neighborhoods, structuring elements, and kernels</a><a id="Neighborhoods,-structuring-elements,-and-kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods,-structuring-elements,-and-kernels" title="Permalink"></a></h1><p>In <code>LocalFilters</code>, a filtering operation, say</p><pre><code class="language-julia hljs">dst = filter(A, B)</code></pre><p>involves, at each index <code>i</code> of a source array <code>A</code>, the values <code>A[i-k]</code> of <code>A</code> for all indices <code>k</code> of <code>B</code>. In <code>LocalFilters</code>, the following terminology is used for <code>B</code>:</p><ul><li><p><code>B</code> is called a <em>neighborhood</em> or a <em>structuring element</em> for mathematical morphology operations (see Section <a href="morphology.html"><em>Non-linear morphological filters</em></a>) if its purpose is to define the indices in the source relatively to a given index in the destination. Such neighborhoods can be hyper-rectangular Cartesian sliding windows represented by a <a href="@ref"><code>RectangularBox</code></a> instance or regions with more complex shapes which are represented by arrays with offset axes and boolean entries (<code>true</code> where entries are part of the neighborhood).</p></li><li><p><code>B</code> is called a <em>kernel</em> when its values are combined by the filter with those of the source. This is typically the case of discrete convolutions and correlations.</p></li></ul><h2 id="Neighborhoods-and-structuring-elements"><a class="docs-heading-anchor" href="#Neighborhoods-and-structuring-elements">Neighborhoods and structuring elements</a><a id="Neighborhoods-and-structuring-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods-and-structuring-elements" title="Permalink"></a></h2><p>A neighborhood (a.k.a. <em>structuring element</em> in mathematical morphology) is a central concept in <code>LocalFilters</code>. The neighborhood defines which values are involved in a local operation for each output value of the filter. Neighborhoods are assumed to be shift invariant but may have any support shape and may have embedded weights (<em>e.g.</em>, to implement <em>local convolution</em>).</p><h3 id="Types-of-neighborhoods"><a class="docs-heading-anchor" href="#Types-of-neighborhoods">Types of neighborhoods</a><a id="Types-of-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-neighborhoods" title="Permalink"></a></h3><p>From the user point of view, there are three kinds of neighborhoods:</p><ul><li><p><strong>Rectangular boxes</strong> are rectangular neighborhoods whose edges are aligned with the axes of array indices and which may be centered or have arbitrary offsets along the dimensions. These neighborhoods are represented by instances of <code>LocalFilters.RectangularBox</code>.</p></li><li><p><strong>Arbitrarily shaped neighborhoods</strong> are neighborhoods with arbitrary shape and offset. These neighborhoods are represented by instances of <code>LocalFilters.Kernel</code> with boolean element type. These neighborhoods are constructed from an array of booleans and an optional starting index.</p></li><li><p><strong>Kernels</strong> are neighborhoods whose elements are weights and which may have arbitrary offset. These neighborhoods are represented by instances of <code>LocalFilters.Kernel</code> with numerical element type. These neighborhoods are constructed from an array of weights and an optional starting index.</p></li></ul><h3 id="Syntaxes-for-neighborhoods"><a class="docs-heading-anchor" href="#Syntaxes-for-neighborhoods">Syntaxes for neighborhoods</a><a id="Syntaxes-for-neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Syntaxes-for-neighborhoods" title="Permalink"></a></h3><ul><li><p>The <em>default neighborhood</em> is a centered hyper-rectangular Cartesian sliding window of width 3 in each of its dimensions. He <em>Cartesian</em> means that the edges of the neighborhood are algned with the array axes.</p></li><li><p>A <em>scalar</em> integer <code>w</code> yields a centered rectangular box of size <code>w</code> along all dimensions. <code>w</code> must be at least equal to 1 and the geometrical center of the box is defined according to the conventions in <code>fftshift</code>.</p></li><li><p>A <em>tuple</em> <code>t</code> of integers yields a centered rectangular box whose size is <code>t[i]</code> along the <code>i</code>-th dimension. All values of <code>t</code> must be larger or equal to 1. Tip: Remember that you can use <code>v...</code> to convert a <em>vector</em> <code>v</code> into a tuple.</p></li><li><p>An <em>array</em> <code>A</code> yields a <code>LocalFilters.Kernel</code> whose coefficients are the values of <code>A</code> and whose neighborhood is the centered bounding-box of <code>A</code>.</p></li><li><p>A <em>Cartesian region</em> <code>R</code> (an instance of <code>CartesianIndices</code>) yields a <code>LocalFilters.RectangularBox</code> which is a rectangular neighborhood whose support contains all relative positions within <code>first(R)</code> and <code>last(R)</code>.</p></li><li><p>A rectangular box neighborhood created by calling <code>LocalFilters.RectangularBox</code> as:</p><pre><code class="language-julia hljs">LocalFilters.RectangularBox(R)
LocalFilters.RectangularBox(I1, I2)
LocalFilters.RectangularBox(dims, offs)
LocalFilters.RectangularBox(inds)</code></pre><p>where <code>R</code> is an instance of<code>CartesianIndices</code>, <code>I1</code> and <code>I2</code> are two <code>CartesianIndex</code> specifying the first and last relative position within the neighborhood, <code>dims</code> and <code>offs</code> are tuples of integers specifying the dimensions of the neighborhood and its offsets, <code>inds</code> are unit ranges.</p><p>Assuming <code>dim</code> is an integer, then:</p><pre><code class="language-julia hljs">LocalFilters.RectangularBox{N}(dim)</code></pre><p>yields an <code>N</code>-dimensional rectangular box of size <code>dim</code> along all dimensions and centered at the geometrical center of the box (with the same conventions as <code>fftshift</code>).</p><p>Similarly, assuming <code>i1</code> and <code>i2</code> are integers, then:</p><pre><code class="language-julia hljs">LocalFilters.RectangularBox{N}(i1:i2)</code></pre><p>yields an <code>N</code>-dimensional rectangular box with index range <code>i1:i2</code> along all dimensions.</p></li></ul><h3 id="Methods-on-a-neighborhood"><a class="docs-heading-anchor" href="#Methods-on-a-neighborhood">Methods on a neighborhood</a><a id="Methods-on-a-neighborhood-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-on-a-neighborhood" title="Permalink"></a></h3><p>The following statements make sense on a neighborhood <code>B</code>:</p><pre><code class="language-julia hljs">eltype(B) -&gt; element type of B
ndims(B)  -&gt; number of dimensions of B
length(B) -&gt; number of elements in the bounding-box of B
size(B)   -&gt; size of the bounding-box of B along all dimensions
size(B,d) -&gt; size of the bounding-box of B along d-th dimension
first(B)  -&gt; CartesianIndex of first position in the bounding-box
             of B relative to its anchor
last(B)   -&gt; CartesianIndex of last position in the bounding-box
             of B relative to its anchor
B[i]      -&gt; yields the kernel value of B at index i</code></pre><p>Note that the index <code>i</code> in <code>B[i]</code> is assumed to be between <code>first(B)</code> and <code>last(B)</code>, for efficiency reasons this is not checked. The type returned by <code>eltype(B)</code> is <code>Bool</code> for a neighborhood which is just defined by its support (<em>e.g.</em> a <code>LocalFilters.CenteredBox</code> or a <code>LocalFilters.RectangularBox</code>), the element type of its kernel otherwise.</p><pre><code class="language-julia hljs">CartesianIndices(B)</code></pre><p>yields the Cartesian indices of relative positions of the bounding-box of neighborhood <code>B</code>.</p><p>If the argument <code>B</code> which defines a neighborhood (see previous section) is not an instance of a type derived from <code>LocalFilters.Neighborhood</code>, it may be explicitly converted by:</p><pre><code class="language-julia hljs">convert(LocalFilters.Neighborhood{N}, B)</code></pre><p>with <code>N</code> the number of dimensions of the target array.</p><h2 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h2><p>A <a href="@ref"><code>LocalFilters.Kernel</code></a> can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology). It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood. In general, it is sufficient to specify <code>::LocalFilters.Kernel{T,N}</code> in the signature of methods, with <code>T</code> the type of the coefficients and <code>N</code> the number of dimensions (the third parameter <code>A</code> of the type is to fully qualify the type of the array of coefficients).</p><p>A kernel is built as:</p><pre><code class="language-julia hljs">B = LocalFilters.Kernel{T}(C, start=default_start(C))</code></pre><p>where <code>C</code> is the array of coefficients (which can be retrieved by <code>coefs(B)</code>) and <code>start</code> the initial <code>CartesianIndex</code> for indexing the kernel (which can be retrieved by <code>first_cartesian_index(B)</code>). The <code>start</code> parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:</p><pre><code class="language-julia hljs">B[k] ≡ C[k + off]</code></pre><p>where <code>off = first_cartesian_index(C) - first_cartesian_index(B)</code>.</p><p>If <code>start</code> is omitted, its value is set so that the <em>origin</em> (whose index is <code>zero(CartesianIndex{N})</code> with <code>N</code> the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see <a href="@ref"><code>LocalFilters.default_start</code></a>). Optional type parameter <code>T</code> is to impose the type of the coefficients.</p><p>To convert the element type of the coefficients of an existing kernel, do:</p><pre><code class="language-julia hljs">LocalFilters.Kernel{T}(K)</code></pre><p>which yields a kernel whose coefficients are those of the kernel <code>K</code> converted to type <code>T</code>.</p><p>It is also possible to convert instances of <a href="@ref"><code>RectangularBox</code></a> into a kernel with boolean coefficients by calling:</p><pre><code class="language-julia hljs">LocalFilters.Kernel(B)</code></pre><p>where <code>B</code> is the neighborhood to convert into an instance of <code>Kernel</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generic/">« Generic local filters</a><a class="docs-footer-nextpage" href="../linear/">Linear filters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 November 2024 17:14">Friday 15 November 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
