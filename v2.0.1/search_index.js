var documenterSearchIndex = {"docs":
[{"location":"neighborhoods/#Neighborhoods,-structuring-elements,-and-kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"In LocalFilters, a filtering operation, say","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"dst = filter(A, B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"involves, at each index i of a source array A, the values A[i-k] of A for all indices k of B. In LocalFilters, the following terminology is used for B:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B is called a neighborhood or a structuring element for mathematical morphology operations (see Section Non-linear morphological filters) if its purpose is to define the indices in the source relatively to a given index in the destination. Such neighborhoods can be hyper-rectangular Cartesian sliding windows represented by a RectangularBox instance or regions with more complex shapes which are represented by arrays with offset axes and boolean entries (true where entries are part of the neighborhood).\nB is called a kernel when its values are combined by the filter with those of the source. This is typically the case of discrete convolutions and correlations.","category":"page"},{"location":"neighborhoods/#Neighborhoods-and-structuring-elements","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods and structuring elements","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A neighborhood (a.k.a. structuring element in mathematical morphology) is a central concept in LocalFilters. The neighborhood defines which values are involved in a local operation for each output value of the filter. Neighborhoods are assumed to be shift invariant but may have any support shape and may have embedded weights (e.g., to implement local convolution).","category":"page"},{"location":"neighborhoods/#Types-of-neighborhoods","page":"Neighborhoods, structuring elements, and kernels","title":"Types of neighborhoods","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"From the user point of view, there are three kinds of neighborhoods:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Rectangular boxes are rectangular neighborhoods whose edges are aligned with the axes of array indices and which may be centered or have arbitrary offsets along the dimensions. These neighborhoods are represented by instances of LocalFilters.RectangularBox.\nArbitrarily shaped neighborhoods are neighborhoods with arbitrary shape and offset. These neighborhoods are represented by instances of LocalFilters.Kernel with boolean element type. These neighborhoods are constructed from an array of booleans and an optional starting index.\nKernels are neighborhoods whose elements are weights and which may have arbitrary offset. These neighborhoods are represented by instances of LocalFilters.Kernel with numerical element type. These neighborhoods are constructed from an array of weights and an optional starting index.","category":"page"},{"location":"neighborhoods/#Syntaxes-for-neighborhoods","page":"Neighborhoods, structuring elements, and kernels","title":"Syntaxes for neighborhoods","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"The default neighborhood is a centered hyper-rectangular Cartesian sliding window of width 3 in each of its dimensions. He Cartesian means that the edges of the neighborhood are algned with the array axes.\nA scalar integer w yields a centered rectangular box of size w along all dimensions. w must be at least equal to 1 and the geometrical center of the box is defined according to the conventions in fftshift.\nA tuple t of integers yields a centered rectangular box whose size is t[i] along the i-th dimension. All values of t must be larger or equal to 1. Tip: Remember that you can use v... to convert a vector v into a tuple.\nAn array A yields a LocalFilters.Kernel whose coefficients are the values of A and whose neighborhood is the centered bounding-box of A.\nA Cartesian region R (an instance of CartesianIndices) yields a LocalFilters.RectangularBox which is a rectangular neighborhood whose support contains all relative positions within first(R) and last(R).\nA rectangular box neighborhood created by calling LocalFilters.RectangularBox as:\nLocalFilters.RectangularBox(R)\nLocalFilters.RectangularBox(I1, I2)\nLocalFilters.RectangularBox(dims, offs)\nLocalFilters.RectangularBox(inds)\nwhere R is an instance ofCartesianIndices, I1 and I2 are two CartesianIndex specifying the first and last relative position within the neighborhood, dims and offs are tuples of integers specifying the dimensions of the neighborhood and its offsets, inds are unit ranges.\nAssuming dim is an integer, then:\nLocalFilters.RectangularBox{N}(dim)\nyields an N-dimensional rectangular box of size dim along all dimensions and centered at the geometrical center of the box (with the same conventions as fftshift).\nSimilarly, assuming i1 and i2 are integers, then:\nLocalFilters.RectangularBox{N}(i1:i2)\nyields an N-dimensional rectangular box with index range i1:i2 along all dimensions.","category":"page"},{"location":"neighborhoods/#Methods-on-a-neighborhood","page":"Neighborhoods, structuring elements, and kernels","title":"Methods on a neighborhood","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"The following statements make sense on a neighborhood B:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"eltype(B) -> element type of B\nndims(B)  -> number of dimensions of B\nlength(B) -> number of elements in the bounding-box of B\nsize(B)   -> size of the bounding-box of B along all dimensions\nsize(B,d) -> size of the bounding-box of B along d-th dimension\nfirst(B)  -> CartesianIndex of first position in the bounding-box\n             of B relative to its anchor\nlast(B)   -> CartesianIndex of last position in the bounding-box\n             of B relative to its anchor\nB[i]      -> yields the kernel value of B at index i","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Note that the index i in B[i] is assumed to be between first(B) and last(B), for efficiency reasons this is not checked. The type returned by eltype(B) is Bool for a neighborhood which is just defined by its support (e.g. a LocalFilters.CenteredBox or a LocalFilters.RectangularBox), the element type of its kernel otherwise.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"CartesianIndices(B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"yields the Cartesian indices of relative positions of the bounding-box of neighborhood B.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"If the argument B which defines a neighborhood (see previous section) is not an instance of a type derived from LocalFilters.Neighborhood, it may be explicitly converted by:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"convert(LocalFilters.Neighborhood{N}, B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"with N the number of dimensions of the target array.","category":"page"},{"location":"neighborhoods/#Kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A LocalFilters.Kernel can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology). It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood. In general, it is sufficient to specify ::LocalFilters.Kernel{T,N} in the signature of methods, with T the type of the coefficients and N the number of dimensions (the third parameter A of the type is to fully qualify the type of the array of coefficients).","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A kernel is built as:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B = LocalFilters.Kernel{T}(C, start=default_start(C))","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where C is the array of coefficients (which can be retrieved by coefs(B)) and start the initial CartesianIndex for indexing the kernel (which can be retrieved by first_cartesian_index(B)). The start parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B[k] ≡ C[k + off]","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where off = first_cartesian_index(C) - first_cartesian_index(B).","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"If start is omitted, its value is set so that the origin (whose index is zero(CartesianIndex{N}) with N the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see LocalFilters.default_start). Optional type parameter T is to impose the type of the coefficients.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"To convert the element type of the coefficients of an existing kernel, do:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"LocalFilters.Kernel{T}(K)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"which yields a kernel whose coefficients are those of the kernel K converted to type T.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"It is also possible to convert instances of RectangularBox into a kernel with boolean coefficients by calling:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"LocalFilters.Kernel(B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where B is the neighborhood to convert into an instance of Kernel.","category":"page"},{"location":"separable/#Efficient-separable-filters-for-associative-operations","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"","category":"section"},{"location":"separable/#Out-of-place-version","page":"Efficient separable filters for associative operations","title":"Out-of-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter method may be called as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst = localfilter([T=eltype(A),] A, dims, op, rngs [, w])","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"to apply the van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs. Optional argument T is the element type of the result dst (by default T = eltype(A)). Optional argument w is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as A which is resized as needed (by calling the resize! method).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Argument dims specifies along which dimension(s) of A the filter is to be applied, it can be a single integer, several integers or a colon : to specify all dimensions. Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that if rngs is a single interval, it is used for every dimension in dims). An interval is either an integer or an integer valued unit range in the form kmin:kmax (an interval specified as a single integer, say k, is the same as specifying k:k).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Assuming a mono-dimensional array A, the single filtering pass:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(dst, A, :, op, rng)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"amounts to computing:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"for all j ∈ [first(axes(A,1)):last(axes(A,1))], with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng). Note that if kmin = kmax = k (which occurs if rng is a simple integer), the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0. This can be exploited to not filter some dimension(s).","category":"page"},{"location":"separable/#In-place-version","page":"Efficient separable filters for associative operations","title":"In-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter! method implement the in-place version of the van Herk-Gil-Werman algorithm:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!([dst = A,] A, dims, op, rngs [, w]) -> dst","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites the contents of dst with the result of the filter and returns dst. The destination array dst must have the same indices as the source A (that is, axes(dst) == axes(A)). If dst is not specified or if dst is A, the operation is performed in-place.","category":"page"},{"location":"separable/#Examples","page":"Efficient separable filters for associative operations","title":"Examples","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be applied by:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, min, -3:3)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Index interval 0 may be specified to do nothing along the corresponding dimension. For instance, assuming A is a three-dimensional array:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, max, (-3:3, 0, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites A by its morphological dilation (i.e. local maximum) in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension). The same result may be obtained with:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, (1,3), max, (-3:3, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"where the second dimension is omitted from the list of dimensions.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The local average of the two-dimensional array A on a centered moving window of size 11×11 can be computed as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter(A, :, +, (-5:5, -5:5))*(1/11)","category":"page"},{"location":"separable/#Efficiency-and-restrictions","page":"Efficient separable filters for associative operations","title":"Efficiency and restrictions","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements. It takes at most 3 operations to filter an element along a given dimension whatever the width p of the considered local neighborhood. For N-dimensional arrays, the algorithm requires only 3N operations per element instead of p^N - 1 operations for a naive implementation. This however requires to make a pass along each dimension so memory page faults may reduce the performances. This is somewhat attenuated by the fact that the algorithm can be applied in-place. For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous. In other words, the algorithm is only applicable for N-dimensional rectangular neighborhoods, so-called hyperrectangles. The structuring element may however be off-centered by arbitrary offsets along each dimension.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To take into account boundary conditions (for now, only nearest neighbor is implemented) and allow for in-place operation, the algorithm allocates a workspace array.","category":"page"},{"location":"separable/#References","page":"Efficient separable filters for associative operations","title":"References","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Marcel van Herk, \"A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels\" in Pattern Recognition Letters 13, 517-521 (1992).\nJoseph Gil and Michael Werman, \"Computing 2-D Min, Median, and Max Filters\" in IEEE Transactions on Pattern Analysis and Machine Intelligence 15, 504-507 (1993).","category":"page"},{"location":"linear/#Linear-filters","page":"Linear filters","title":"Linear filters","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"LocalFilters provides a few linear filters: localmean or localmean! to compute the mean of values in a neighborhood, and convolve or convolve! to compute the discrete convolution of an array by a kernel.","category":"page"},{"location":"linear/#Local-mean","page":"Linear filters","title":"Local mean","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The localmean method yields the local mean of an array A in a neighborhood B:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"localmean(A, B=3) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The result dst is an array similar to A. If B is not specified, the neighborhood is a hyper-rectangular moving window of size 3 in every dimension. Otherwise, B may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as A. If B is a single odd integer (as it is by default), the neighborhood is assumed to be a hyper-rectangular moving window of size B in every dimension.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"To avoid allocations, use the in-place version localmean! and call:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"localmean!(dst, A, B=3) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to overwrite dst with the local mean of A in the neighborhood defined by B.","category":"page"},{"location":"linear/#Convolution","page":"Linear filters","title":"Convolution","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The convolve method yields the discrete convolution of an array by a kernel. Its syntax is:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"convolve(A, B) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to yield the discrete convolution of array A by the kernel defined by B. The result dst is an array similar to A.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Using Sup(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for k ∈ Sup(B) ∩ (i - Sup(A))\n        v += A[i-k]*B[k]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"with T the type of the product of elements of A and B, and where Sup(B) ∩ (i - Sup(A)) denotes the subset of indices k such that k ∈ Sup(B) and i - k ∈ Sup(A) and thus for which B[k] and A[i-k] are valid.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Following the conventions in localfilter!, the discrete convolution can also be expressed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for j ∈ Sup(A) ∩ (i - Sup(B))\n        v += A[j]*B[i-j]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"If the kernel B is an array of booleans, the discrete convolution is computed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = eltype(A)\nfor i ∈ Sup(A)\n    v = zero(T)\n    for j ∈ Sup(A) ∩ (i - Sup(B))\n        if B[i-j]\n            v += A[j]\n        end\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which amounts to computing the local sum of the values of A in the neighborhood defined by the true entries of B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"To avoid allocations, use the in-place version convolve! and call:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"convolve!(dst, A, B) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to overwrite dst with the discrete convolution of A by the kernel B.","category":"page"},{"location":"nonlinear/#Non-linear-filters","page":"Non-linear filters","title":"Non-linear filters","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"LocalFilters provides a number of non-linear filters such as the bilateral filter and mathematical morphology filters. The latter are described in the Mathematical morphology section.","category":"page"},{"location":"nonlinear/#The-bilateral-filter","page":"Non-linear filters","title":"The bilateral filter","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter([T=float(eltype(A)),] A, F, G, ...)","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"yields the result of applying the bilateral filter on array A.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Argument F specifies how to smooth the differences in values. It may be function which takes two values from A as arguments and returns a nonnegative weight. It may be a real which is assumed to be the standard deviation of a Gaussian.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Arguments G, ... specify the settings of the distance filter for smoothing differences in coordinates. There are several possibilities:","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"G, ... can be a LocalFilters.Kernel instance (specified as a single argument).\nArgument G may be a function taking as argument the Cartesian index of the coordinate differences and returning a nonnegative weight. Argument G may also be a real specifying the standard deviation of the Gaussian used to compute weights. Subsequent arguments ... are to specify the neighborhood where to apply the distance filter function, they can be a Neighborhood object such as a RectangularBox or anything that may defined a neighborhood such as an odd integer assumed to be the width of the neighborhood along every dimensions of A. If a standard deviation σ is specified for G with no subsequent arguments, a default window of radius 3σ is assumed.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Optional argument T can be used to force the element type used for (most) computations. This argument is needed if the element type of A is not a real.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter! for an in-place version of this function.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter!([T=float(eltype(A)),] dst, A, F, G, ...) -> dst","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"overwrites dst with the result of applying the bilateral filter on array A and returns dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter for a description of the other arguments than dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See wikipedia for a description of the bilateral filter.","category":"page"},{"location":"morphology/#Non-linear-morphological-filters","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"","category":"section"},{"location":"morphology/#Basic-morphological-operations","page":"Non-linear morphological filters","title":"Basic morphological operations","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Erosion and dilation are the basic operations of mathematical morphology, they are implemented by methods erode and dilate:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode(A, R=3) -> Amin\ndilate(A, R=3) -> Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which respectively return the local minima Amin and the local maxima Amax of argument A in a structuring element defined by R. The notion of structuring element in mathematical morphology is equlvalent to that of neighborhood in LocalFilters. The returned result is similar to A (same size and type). If R is not specified, a default hyper-rectangular moving window of size 3 in every dimension of A is used. If the structuring element R is a simple hyper-rectangular moving window, the much faster van Herk-Gil-Werman algorithm is used","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The localextrema method combines these two operations in one call:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"localextrema(A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Calling localextrema is usually almost twice as fast as calling erode and dilate.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"To avoid allocating new arrays, the methods erode!, dilate!, and localextrema! provide in-place versions which apply the operation to A with structuring element R and store the result in the provided arrays Amin and/or Amax:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(Amin, A, R=3) -> Amin\ndilate!(Amax, A, R=3) -> Amax\nlocalextrema!(Amin, Amax, A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"If the structuring element R is a simple hyper-rectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(A, R=3) -> A\ndilate!(A, R=3) -> A","category":"page"},{"location":"morphology/#Opening-and-closing-filters","page":"Non-linear morphological filters","title":"Opening and closing filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing(A, R=3)\nopening(A, R=3)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"respectively perform a closing or an opening of array A by the structuring element R. If R is not specified, a default hyper-rectangular moving window of size 3 in every dimension of A is used. A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The in-place versions are:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing!(dst, wrk, A, R=3) -> dst\nopening!(dst, wrk, A, R=3) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which perform the operation on the source A and store the result in destination dst using wrk as a workspace array. The 3 arguments dst, wrk, and A must be similar arrays; dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.","category":"page"},{"location":"morphology/#Top-hat-and-bottom-hat-filters","page":"Non-linear morphological filters","title":"Top-hat and bottom-hat filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods top_hat and bottom_hat perform a summit/valley detection by applying a top-hat filter to an array. They are called as:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(A, R[, S]) -> dst\nbottom_hat(A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"to yield the result of the filter applied to array A. Argument R defines the structuring element for the feature detection. Optional argument S specifies the structuring element for smoothing A prior to the top-/bottom-hat filter. If R and S are specified as the radii of the structuring elements, then S should be smaller than R. For instance:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(bitmap, 3, 1)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"may be used to detect text or lines in a bitmap image.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods LocalFilters.top_hat! and LocalFilters.bottom_hat! implement the in-place versions of these filters:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat!(dst, wrk, A, R[, S]) -> dst\nbottom_hat!(dst, wrk, A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"apply the top-/bottom-hat filter on the source A and store the result in the destination dst using wrk as a workspace array. The 3 arguments dst, wrk, and A must be similar but different arrays. The destination dst is returned.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following summarizes the documentation of types and methods provided by the LocalFilters package. This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Linear-filters","page":"Reference","title":"Linear filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"LocalFilters provides convolutive filters which are shift-invariant linear filters.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"localmean\nlocalmean!\nconvolve\nconvolve!","category":"page"},{"location":"reference/#LocalFilters.localmean","page":"Reference","title":"LocalFilters.localmean","text":"localmean(A, [ord=ForwardFilter,] B=3)\n\nyields the local mean of A in a neighborhood defined by B. The result is an array similar to A. If B is not specified, the neighborhood is a hyper-rectangular sliding window of size 3 in every dimension. Otherwise, B may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as A. If B is a single odd integer (as it is by default), the neighborhood is assumed to be a hyper-rectangular sliding window of size B in every dimension.\n\nSee also localmean! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmean!","page":"Reference","title":"LocalFilters.localmean!","text":"localmean!(dst, A, [ord=ForwardFilter,] B=3) -> dst\n\noverwrites dst with the local mean of A in a neighborhood defined by B and returns dst.\n\nSee also localmean and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve","page":"Reference","title":"LocalFilters.convolve","text":"convolve(A, B=3)\n\nyields the discrete convolution of array A by the kernel defined by B. The result dst is an array similar to A.\n\nUsing Sup(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes:\n\nT = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for j ∈ Sup(B) ∩ (i - Sup(A))\n        v += A[i-j]*B[j]\n    end\n    dst[i] = v\nend\n\nwith T the type of the product of elements of A and B, and where Sup(B) ∩ (i - Sup(A)) denotes the subset of indices k such that k ∈ Sup(B) and i - k ∈ Sup(A) and thus for which B[k] and A[i-k] are valid.\n\nSee also convolve! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve!","page":"Reference","title":"LocalFilters.convolve!","text":"convolve!(dst, A, B) -> dst\n\noverwrites dst with the discrete convolution of A by the kernel B and returns dst.\n\nSee also convolve and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-morphology","page":"Reference","title":"Mathematical morphology","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"erode\nerode!\ndilate\ndilate!\nlocalextrema\nlocalextrema!\nclosing\nclosing!\nopening\nopening!\ntop_hat\nLocalFilters.top_hat!\nbottom_hat\nLocalFilters.bottom_hat!\nstrel","category":"page"},{"location":"reference/#LocalFilters.erode","page":"Reference","title":"LocalFilters.erode","text":"erode(A, [ord=ForwardFilter,] B=3) -> Amin\n\nyields the erosion of A by the structuring element defined by B. The erosion is the array of local minima of A. The returned result Amin is similar to A (same size and type).\n\nIf B is not a kernel (that is, if B is not an array or is an instance of CartesianIndices), kernel(Dims{N},B) is called to build a kernel with N the number of dimensions of A.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used.\n\nAn erosion is one of the most basic operations of mathematical morphology. See erode! for an in-place version of the method, dilate for retrieving the local maxima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.erode!","page":"Reference","title":"LocalFilters.erode!","text":"erode!(Amin, A, [ord=ForwardFilter,] B=3) -> Amin\n\noverwrites Amin with the erosion of the array A by the structuring element defined by B and returns Amin.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:\n\nerode!(A, [ord=ForwardFilter,] B=3) -> A\n\nSee erode for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate","page":"Reference","title":"LocalFilters.dilate","text":"dilate(A, [ord=ForwardFilter,] B=3) -> Amax\n\nyields the dilation of A by the structuring element defined by B. The dilation is the array of local maxima of A. The returned result Amax is similar to A (same size and type).\n\nIf B is not a kernel (that is, if B is not an array or is an instance of CartesianIndices), kernel(Dims{N},B) is called to build a kernel with N the number of dimensions of A.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used.\n\nA dilation is one of the most basic operations of mathematical morphology. See dilate! for an in-place version of the method, erode for retrieving the local minima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate!","page":"Reference","title":"LocalFilters.dilate!","text":"dilate!(Amax, A, [ord=ForwardFilter,] B=3) -> Amax\n\noverwrites Amax with a dilation of the array A by the structuring element defined by B and returns Amax.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:\n\ndilate!(A, [ord=ForwardFilter,] B=3) -> A\n\nSee dilate for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema","page":"Reference","title":"LocalFilters.localextrema","text":"localextrema(A, [ord=ForwardFilter,] B=3) -> Amin, Amax\n\nyields the results of performing an erosion and a dilation of A by the structuring element defined by B in a single pass. Calling this method is usually almost twice as fast as calling erode and dilate.\n\nSee localextrema! for an in-place version of the method, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema!","page":"Reference","title":"LocalFilters.localextrema!","text":"localextrema!(Amin, Amax, A, [ord=ForwardFilter,] B=3) -> Amin, Amax\n\noverwrites Amin and Amax with, respectively, an erosion and a dilation of the array A by the structuring element defined by B in a single pass.\n\nSee localextrema for an out-of-place version for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing","page":"Reference","title":"LocalFilters.closing","text":"closing(A, [ord=ForwardFilter,] B=3) -> dst\n\nyields a closing of array A by the structuring element defined by B. A closing is a dilation followed by an erosion. The result dst is an array similar to A.\n\nSee closing! for an in-place version of the method, opening for a related filter, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing!","page":"Reference","title":"LocalFilters.closing!","text":"closing!(dst, wrk, A, B=3) -> dst\n\noverwrites dst with the result of a closing of A by the structuring element defined by B using wrk as a workspace array. The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.\n\nSee closing for a description of this kind of filter and for the meaning of the arguments.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening","page":"Reference","title":"LocalFilters.opening","text":"opening(A, B=3) -> dst\n\nyields an opening of array A by the structuring element defined by B. An opening is an erosion followed by a dilation. The result dst is an array similar to A.\n\nSee opening! for an in-place version of the method, closing for a related filter, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening!","page":"Reference","title":"LocalFilters.opening!","text":"opening!(dst, wrk, A, B=3) -> dst\n\noverwrites dst with the result of an opening of A by the structuring element defined by B using wrk as a workspace array. The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.\n\nSee opening for a description of this kind of filter and for the meaning of the arguments.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat","page":"Reference","title":"LocalFilters.top_hat","text":"top_hat(A, B=3 [, C]) -> dst\n\nperforms a summit detection by applying a top-hat filter to array A using the structuring element defined by B for the feature detection. Top-hat filtering is equivalent to:\n\ndst = A .- opening(A, B)\n\nOptional argument C specifies the structuring element for smoothing A prior to top-hat filtering. If B and C are specified as the radii of the structuring elements, then C should be smaller than B. For instance:\n\ntop_hat(bitmap, 3, 1)\n\nmay be used to detect text or lines in a bitmap image.\n\nSee bottom_hat for a related operation, LocalFilters.top_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat!","page":"Reference","title":"LocalFilters.top_hat!","text":"LocalFilters.top_hat!(dst, wrk, A, [ord=ForwardFilter,] B=3) -> dst\n\noverwrites dst with the result of a top-hat filter applied to A with structuring element B, and using wrk as a workspace whose contents is not preserved. The arguments A, dst, and wrk must be similar but different arrays. The destination dst is returned.\n\nSee also top_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat","page":"Reference","title":"LocalFilters.bottom_hat","text":"bottom_hat(A, B=3 [, C]) -> dst\n\nperforms a valley detection by applying a bottom-hat filter to array A using the structuring element defined by B for the feature detection. Bottom-hat filtering is equivalent to:\n\ndst = closing(A, B) .- A\n\nOptional argument C specifies the structuring element for smoothing A prior to bottom-hat filtering. If B and C are specified as the radii of the structuring elements, then C should be smaller than B.\n\nSee top_hat for a related operation, LocalFilters.bottom_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat!","page":"Reference","title":"LocalFilters.bottom_hat!","text":"LocalFilters.bottom_hat!(dst, wrk, A, B=3) -> dst\n\noverwrites dst with the result of a bottom-hat filter applied to A with structuring element B and optional smoothing element C. Argument wrk is a workspace array whose contents is not preserved. The arguments A, dst, and wrk must be similar but different arrays. The destination dst is returned.\n\nSee also bottom_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.strel","page":"Reference","title":"LocalFilters.strel","text":"strel(T, A)\n\nyields a structuring element suitable for mathematical morphology operations. The result is an array whose elements have type T (which can be Bool or a floating-point type). Argument A can be a hyper-rectangular Cartesian sliding window or an array with boolean elements.\n\nIf T is a floating-point type, then the result is a so-called flat structuring element whose coefficients are zero(T) inside the shape defined by A and -T(Inf) elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Other-non-linear-filters","page":"Reference","title":"Other non-linear filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"bilateralfilter\nbilateralfilter!","category":"page"},{"location":"reference/#LocalFilters.bilateralfilter","page":"Reference","title":"LocalFilters.bilateralfilter","text":"bilateralfilter([T=float(eltype(A)),] A, F, [ord=ForwardFilter,] G...=3)\n\nyields the result of applying the bilateral filter on array A.\n\nArgument F specifies how to smooth the differences in values. It can be:\n\na function, say f, which is called as f(A[i],A[j]) to yield a nonnegative weight for i the central index and j the index in a nearby position;\na positive real, say σ, which is assumed to be the standard deviation of a Gaussian.\n\nArguments G, ... specify the settings of the distance filter for smoothing differences in coordinates. There are several possibilities:\n\nG... = wgt an array of nonnegative weights or of booleans. The axes of wgt must have offsets so that the zero index is part of the indices of wgt.\nG... = f, w with f a function and w any kind of argument that can be used to build a window win specifying the extension of the neighborhood. The value of the distance filter will be max(f(i),0) for all Cartesian index i of win such that win[i] is true. See kernel for the different ways to specify a window.\nG... = σ or , G... = σ, w with σ a positive real assumed to be the standard deviation of a Gaussian function and w any kind of argument that can be used to build a window win specifying the extension of the neighborhood. If w is not specified, a default window of size ±3σ is assumed.\n\nOptional argument T can be used to force the element type of the result. This argument is needed if the element type of A is not a real.\n\nSee bilateralfilter! for an in-place version of this function and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bilateralfilter!","page":"Reference","title":"LocalFilters.bilateralfilter!","text":"bilateralfilter!(dst, A, F, [ord=ForwardFilter,] G...) -> dst\n\noverwrites dst with the result of applying the bilateral filter on array A and returns dst.\n\nSee bilateralfilter for a description of the other arguments than dst and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Generic-driver-for-custom-local-filters","page":"Reference","title":"Generic driver for custom local filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"localfilter\nlocalfilter!","category":"page"},{"location":"reference/#LocalFilters.localfilter","page":"Reference","title":"LocalFilters.localfilter","text":"localfilter([T=eltype(A),] A, dims, op, [ord=ForwardFilter,]\n            rngs[, wrk]) -> dst\n\nyields the result of applying van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs. Optional argument wrk is a workspace array with elements of type T which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as A and it is resized as needed (by calling the resize! method). The optional argument T allows to specify another type of element than eltype(A) for the result.\n\nArgument dims specifies along which dimension(s) of A the filter is to be applied, it can be a single integer, a tuple of integers, or a colon : to apply the operation to all dimensions. Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that if rngs is a single interval, it is used for every dimension in dims). An interval is either an integer or an integer valued unit range in the form kmin:kmax. An interval specified as a single integer yields an approximately centered range og this length.\n\nAssuming a mono-dimensional array A, the single filtering pass:\n\ndst = localfilter(A, :, op, rng)\n\namounts to computing (assuming forward ordering):\n\ndst[j] =  A[i+kmin] ⋄ A[i+kmin+1] ⋄ ... ⋄ A[i+kmax-1] ⋄ A[i+kmax]\n\nfor all j ∈ axes(dst,1), with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng). Note that if kmin = kmax = k, the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0. This can be exploited to not filter some dimension(s).\n\nFlat boundary conditions are assumed for A[i+k] in the above formula.\n\nExamples\n\nThe morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be obtained by:\n\nlocalfilter(A, :, min, -3:3)\n\nIndex interval 0:0 may be specified to do nothing along the corresponding dimension. For instance, assuming A is a three-dimensional array:\n\nlocalfilter(A, :, max, (-3:3, 0:0, -4:4))\n\nyields the morphological dilation (i.e. local maximum) of A in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension). The same result may be obtained with:\n\nlocalfilter(A, (1,3), max, (-3:3, -4:4))\n\nwhere the second dimension is omitted from the list of dimensions.\n\nThe local average of the two-dimensional array A on a centered moving window of size 11×11 can be computed as:\n\nlocalfilter(A, :, +, (-5:5, -5:5))*(1/11)\n\nSee localfilter! for an in-place version of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localfilter!","page":"Reference","title":"LocalFilters.localfilter!","text":"localfilter!([dst = A,] A, dims, op, [ord=ForwardFilter,] rngs[, wrk])\n\noverwrites the contents of dst with the result of applying van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs and using optional argument wrk as a workspace array. The destination dst must have the same indices as the source A (that is, axes(dst) == axes(A)). Operation may be done in-place and dst and A can be the same; this is the default behavior if dst is not specified.\n\nSee localfilter for a full description of the method.\n\nThe in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be obtained by:\n\nlocalfilter!(A, :, min, -3:3)\n\n\n\n\n\nlocalfilter!(dst, A, [ord = ForwardFilter,] B, initial, update,\n             final = identity) -> dst\n\noverwrites the destination dst with the result of a local filter applied to the source A, on a relative neighborhood defined by B, and implemented by initial, update, and final. The purpose of these latter arguments is explained by the following pseudo-codes implementing the local filtering. If ord = ForwardFilter:\n\n@inbounds for i ∈ indices(dst)\n    v = initial\n    for j ∈ indices(A) ∩ (indices(B) + i)\n        v = update(v, A[j], B[j-i])\n    end\n    dst[i] = final(v)\nend\n\nelse if ord = ReverseFilter:\n\n@inbounds for i ∈ indices(dst)\n    v = initial\n    for j ∈ indices(A) ∩ (i - indices(B))\n        v = update(v, A[j], B[i-j])\n    end\n    dst[i] = final(v)\nend\n\nwhere indices(A) denotes the range of indices of any array A while indices(B) + i and i - indices(B) respectively denote the set of indices j such that j - i ∈ indices(B) and i - j ∈ indices(B). In other words, j ∈ indices(A) ∩ (i - indices(B)) means all indices j such that j ∈ indices(A) and i - j ∈ indices(B) so that A[j] and B[i-j] are in-bounds.\n\nFor example, implementing a local minimum filter (that is, an erosion), is as simple as:\n\nlocalfilter!(dst, A, ord, B, typemax(eltype(a)),\n             (v,a,b) -> ifelse(b, min(v,a), v))\n\nAs another example, implementing a convolution by B writes:\n\nT = promote_type(eltype(A), eltype(B))\nlocalfilter!(dst, A, ord, B, zero(T), (v,a,b) -> v + a*b)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Neighborhood\nRectangularBox\nLocalFilters.Kernel\nLocalFilters.ConstantProducer","category":"page"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"LocalFilters.default_start\nLocalFilters.ball","category":"page"},{"location":"reference/#LocalFilters.ball","page":"Reference","title":"LocalFilters.ball","text":"LocalFilters.ball(Dims{N}, r)\n\nyields a boolean mask which is a N-dimensional array with all dimensions odd and equal and set to true where position is inside a N-dimensional ball of radius r.\n\nTo have a mask with centered index ranges, call:\n\nLocalFilters.centered(LocalFilters.ball(Dims{N}, r))\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The LocalFilters package provides local linear and non-linear filters for Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code of LocalFilters is available on GitHub.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"generic.md\", \"neighborhoods.md\", \"linear.md\", \"nonlinear.md\",\n         \"morphology.md\", \"separable.md\", \"reference.md\"]","category":"page"},{"location":"generic/#Generic-local-filters","page":"Generic local filters","title":"Generic local filters","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Most filters provided by the LocalFilters package are implemented by the generic localfilter! method.","category":"page"},{"location":"generic/#The-localfilter!-method","page":"Generic local filters","title":"The localfilter! method","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"A local filtering operation can be performed by calling the localfilter! method as follows:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B, initial, update, final = identity) -> dst","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where dst is the destination, A is the source, B defines the neighborhood, initial gives the initial value of the state variable, update is a function to update the state variable for each entry of the neighborhood, and final is a function to yield the local result of the filter given the final value of the state variable. The purposes of these parameters are explained by the following pseudo-code implementing the local filtering:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"@inbounds for i ∈ indices(dst)\n    v = initial\n    for j ∈ indices(A) ∩ (indices(B) + i)\n        v = update(v, A[j], B[j-i])\n    end\n    dst[i] = final(v)\nend","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where indices(A) denotes the set of indices of A while indices(B) + i denotes the set of indices j such that j - i ∈ indices(B) with indices(B) the set of indices of B. In other words, j ∈ indices(A) ∩ (indices(B) + i) means all indices j such that j ∈ indices(A) and j - i ∈ indices(B), hence A[j] and B[j-i] are in-bounds. In LocalFilters, indices i and j are multi-dimensional Cartesian indices, thus indices(A) is the analogous of CartesianIndices(A) in Julia.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The behavior of the filter is fully determined by the neighborhood B (see Section Neighborhoods, structuring elements, and kernels), by the type and initial value of the state variable v, and by the methods:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"update(v, a, b) which yields the updated state variable v given the state variable v, a = A[j], and b = B[j-i];\nfinal(v) which yields the result of the filter given the state variable v.","category":"page"},{"location":"generic/#Examples","page":"Generic local filters","title":"Examples","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"For example, implementing a local minimum filter (that is, an erosion), is as simple as:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B, typemax(a),\n             (v,a,b) -> min(v,a),\n             (d,i,v) -> @inbounds(d[i] = v))","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"This is typically how mathematical morphology methods are implemented in LocalFilters.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"As another example, implementing a convolution by B writes:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B,\n             (a)     -> zero(a),\n             (v,a,b) -> v + a*b)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Apart from specializations to account for the type of neighborhood defined by B, it is essentially the way the convolve and convolve! methods (described in the Section Linear filters) are implemented in LocalFilters.","category":"page"}]
}
