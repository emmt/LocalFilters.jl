var documenterSearchIndex = {"docs":
[{"location":"neighborhoods/#Neighborhoods,-structuring-elements,-and-kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"","category":"section"},{"location":"neighborhoods/#Definitions","page":"Neighborhoods, structuring elements, and kernels","title":"Definitions","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Neighborhoods (a.k.a. structuring elements in mathematical morphology) and kernels are central concepts in LocalFilters. The neighborhood defines which values are involved in a local operation for each output value of the filter. Neighborhoods are assumed to be shift invariant but may have any support shape and may have embedded weights (e.g., to implement local convolution). In this latter case, they are called kernels.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"In LocalFilters, a filtering operation, say","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"dst = filter(A, B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"involves, at each index i of a source array A, the values A[i±k] of A for all indices k of B and where:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"i ± k = i + k for operations like correlations where A and B can both be accessed in forward order of their indices (which is generally faster);\ni ± k = i - k for operations like convolutions where one of A or B must be accessed in reverse order of its indices (which is generally slower).","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"In LocalFilters, the following terminology is used for B:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B is called a neighborhood or a structuring element for mathematical morphology operations (see Section Non-linear morphological filters) if its purpose is to define the indices in the source relatively to a given index in the destination. Such neighborhoods are represented by arrays with Boolean entries (true where entries are part of the neighborhood) and with as many dimensions as the source array A.\nB is called an hyper-rectangular box if it is a sliding window whose edges are aligned with the Cartesian axes of the array. Such simple neighborhoods are like the previous ones but with all entries equal to true, they are most efficiently represented by fast uniform arrays like FastUniformArray{Bool,N} instances from the StructuredArrays package. Another advantage of hyper-rectangular boxes is that they define a separable structuring element which may be exploited for very fast morphological operations by the van Herk-Gil-Werman algorithm whose numerical complexity does not depend on the size of the neighborhood (see localfilter!).\nB is called a kernel when its values are combined by the filter with those of the source. This is typically the case of discrete convolutions and correlations. Kernels are represented by AbstractArray{T,N} instances, with T the numerical type of the weights and N the number of dimensions.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"From the user point of view, B whether it is a neighborhood, a structuring element, an hyper-rectangular box, a sliding window, or a kernel is thus just an array (usually of small size) with the same number of dimensions as the source array A","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"In addition, B may have arbitrary index offsets, to make it centered for example. For hyper-rectangular neighborhoods, FastUniformArray instances (from the StructuredArrays package) may directly have custom index offsets. For other neighborhoods and kernels, offset arrays (from the OffsetArrays package) can be used to implement such offsets.","category":"page"},{"location":"neighborhoods/#Simple-rules-for-specifying-neighborhoods-and-kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Simple rules for specifying neighborhoods and kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"To facilitate specifying N-dimensional neighborhoods and kernels in the filters provided by LocalFilters, the following rules are applied to convert argument B to a suitable neighborhood or kernel:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"If B is an N-dimensional array, it is used unchanged. Hyper-rectangular boxes or symmetries may however be automatically detected to choose the fastest filtering method.\nIf B is a 2-tuple ofN-dimensional Cartesian indices, say, (I_first,I_last) each of type CartesianIndex{N}, then the corresponding neighborhood is an hyper-rectangular box whose first and last indices are I_first and I_last.\nIf B is a N-dimensional Cartesian range of type of type CartesianIndices{N}, then the corresponding neighborhood is an hyper-rectangular box whose first and last indices are given by this Cartesian range.\nIf B is an integer or an integer-valued unit range, it is interpreted as the length or the range of indices of the neighborhood along each dimension. In the case of a simple length, say, len, the index range of the neighborhood will be approximately centered using the same conventions as for fftshift: -i:i for odd lengths and -i:i-1 for even ones and with i = len ÷ 2.\nOtherwise B may be specified as a N-tuple of lengths or ranges (the two can be mixed), one for each dimension and where lengths are interpreted as in the previous case.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Note that all these cases except the first one correspond to hyper-rectangular boxes. The default neighborhood is B = 3 which corresponds to a centered hyper-rectangular sliding window of width 3 in each of its dimensions.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"This assumed conversion may be explicitly performed by calling the kernel method:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"kernel(Dims{N}, B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"yields the N-dimensional neighborhood or kernel corresponding to B. If the number N of dimensions can be inferred from B, argument Dims{N} can be omitted.","category":"page"},{"location":"neighborhoods/#Simple-operations-on-kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Simple operations on kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"If B is an N-dimensional array representing a neighborhood or a kernel, its indices may be centered by calling the LocalFilters.centered method:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"C = LocalFilters.centered(B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"which yields an array C with the same dimensions and values as B but with offset axes. This even work for arrays already centered or with offset axes that are not centered. Note that this method follows the same conventions as for fftshift (explained above) and has thus a slightly different semantic than the OffsetArrays.centered method which assumes that the centered range of an even dimension 1-i:i instead of -i:i-1.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"It may be convenient to reverse a kernel or a neighborhood, this is done by calling the reverse_kernel method:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"R = reverse_kernel(B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"which yields an array R with the same dimensions and values as B but such that R[i] = B[-i] for any index i such that -i is in-bounds for B. This may be useful to perform a discrete convolution by the kernel B by a discrete correlation by R which is usually faster. Note that the reverse_kernel method reverses the order of the values of B as the base reverse method but also negates the axis ranges.","category":"page"},{"location":"neighborhoods/#Hyper-balls","page":"Neighborhoods, structuring elements, and kernels","title":"Hyper-balls","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"To build a neighborhood, or a structuring element that is a N-dimensional hyper-ball of radius r call:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"LocalFilters.ball(Dims{N}, r)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"For instance:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"julia> B = LocalFilters.ball(Dims{2}, 3.5)\n7×7 OffsetArray(::Matrix{Bool}, -3:3, -3:3) with eltype Bool with indices -3:3×-3:3:\n 0  0  1  1  1  0  0\n 0  1  1  1  1  1  0\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n 0  1  1  1  1  1  0\n 0  0  1  1  1  0  0","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"This neighborhood is geometrically centered thanks to offset axes, to have a 1-based indices, you can do:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"julia> B = LocalFilters.ball(Dims{2}, 3.5).parent\n7×7 Matrix{Bool}:\n 0  0  1  1  1  0  0\n 0  1  1  1  1  1  0\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n 1  1  1  1  1  1  1\n 0  1  1  1  1  1  0\n 0  0  1  1  1  0  0","category":"page"},{"location":"separable/#Efficient-separable-filters-for-associative-operations","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"","category":"section"},{"location":"separable/#Out-of-place-version","page":"Efficient separable filters for associative operations","title":"Out-of-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter method may be called as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst = localfilter([T=eltype(A),] A, dims, op, rngs [, w])","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"to apply the van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs. Optional argument T is the element type of the result dst (by default T = eltype(A)). Optional argument w is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as A (w is resized as needed by calling resize!).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Argument dims specifies along which dimension(s) of A the filter is to be applied, it can be a single integer, several integers or a colon : to specify all dimensions. Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that if rngs is a single interval, it is used for every dimension in dims). An interval is either an integer or an integer valued unit range in the form kmin:kmax (an interval specified as a single integer, say k, is the same as specifying k:k).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Assuming a mono-dimensional array A, the single filtering pass:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(dst, A, :, op, rng)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"amounts to computing:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"for all j ∈ [firstindex(A):lastindex(A)], with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng). Note that if rng = k:k or rng = k with k an integer, the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0. This can be exploited to not filter some dimension(s).","category":"page"},{"location":"separable/#In-place-version","page":"Efficient separable filters for associative operations","title":"In-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter! method implements the in-place version of the van Herk-Gil-Werman algorithm:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!([dst = A,] A, dims, op, rngs [, w]) -> dst","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites the contents of dst with the result of the filter and returns dst. The destination array dst must have the same indices as the source A (that is, axes(dst) == axes(A) must hold). If dst is not specified or if dst is A, the operation is performed in-place.","category":"page"},{"location":"separable/#Examples","page":"Efficient separable filters for associative operations","title":"Examples","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be done by:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, min, -3:3)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"As said before, index interval 0 may be specified to do nothing along the corresponding dimension. For instance, assuming A is a three-dimensional array:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, max, (-3:3, 0, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites A by its morphological dilation (i.e. local maximum) in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension). The same result may be obtained with:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, (1,3), max, (-3:3, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"where the second dimension is omitted from the list of dimensions.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The local average of the two-dimensional array A on a centered moving window of size 11×11 can be computed as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter(A, :, +, (-5:5, -5:5))*(1/11^2)","category":"page"},{"location":"separable/#Efficiency-and-restrictions","page":"Efficient separable filters for associative operations","title":"Efficiency and restrictions","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements. It takes at most 3 operations to filter an element along a given dimension whatever the width p of the considered local neighborhood. For N-dimensional arrays, the algorithm requires only 3N operations per element instead of p^N - 1 operations for a naive implementation. This however requires to make a pass along each dimension so memory page faults may reduce the performances. This is somewhat attenuated by the fact that the algorithm can be applied in-place. For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous. In other words, the algorithm is only applicable for N-dimensional rectangular neighborhoods, so-called hyperrectangles. The structuring element may however be off-centered by arbitrary offsets along each dimension.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To take into account boundary conditions (for now, only nearest neighbor is implemented) and allow for in-place operation, the algorithm allocates a workspace array.","category":"page"},{"location":"separable/#References","page":"Efficient separable filters for associative operations","title":"References","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Marcel van Herk, \"A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels\" in Pattern Recognition Letters 13, 517-521 (1992).\nJoseph Gil and Michael Werman, \"Computing 2-D Min, Median, and Max Filters\" in IEEE Transactions on Pattern Analysis and Machine Intelligence 15, 504-507 (1993).","category":"page"},{"location":"linear/#Linear-filters","page":"Linear filters","title":"Linear filters","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"LocalFilters provides a few linear filters: localmean or localmean! to compute the mean of values in a neighborhood, convolve or convolve! to compute the discrete convolution of an array by a kernel, and correlate or correlate! to compute the discrete correlation of an array by a kernel.","category":"page"},{"location":"linear/#Local-mean","page":"Linear filters","title":"Local mean","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The localmean method yields the local mean of an array A in a neighborhood B:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"dst = localmean(A, B=3)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The result dst is an array similar to A. See Section Simple rules for specifying neighborhoods and kernels for the interpretation of B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The in-place version localmean! may be used to avoid allocations:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"localmean!(dst, A, B=3)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which overwrites dst with the local mean of A in the neighborhood defined by B and returns dst.","category":"page"},{"location":"linear/#Discrete-convolution","page":"Linear filters","title":"Discrete convolution","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Call the convolve method as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"dst = convolve(A, B)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to compute the discrete convolution of array A by the kernel defined by B. The result dst is an array similar to A.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Using indices(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes (see Section Discrete convolution and correlation):","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for k ∈ indices(B) ∩ (i - indices(A))\n        v += A[i-k]*B[k]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"with T a suitable element type for the result (see Section Element type of the result below) and where indices(B) ∩ (i - indices(A)) denotes the subset of indices k such that k ∈ indices(B) and i - k ∈ indices(A) and thus for which B[k] and A[i-k] are valid.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Following the conventions in localfilter!, the discrete convolution can also be expressed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for j ∈ indices(A) ∩ (i - indices(B))\n        v += A[j]*B[i-j]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"If the kernel B is an array of Booleans, the discrete convolution is computed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for j ∈ indices(A) ∩ (i - indices(B))\n        if B[i-j]\n            v += A[j]\n        end\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which amounts to computing the local sum of the values of A in the neighborhood defined by the true entries of B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The in-place version convolve! may be used to avoid allocations:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"convolve!(dst, A, B)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which overwrites dst with the discrete convolution of A by the kernel B and returns dst.","category":"page"},{"location":"linear/#Discrete-correlation","page":"Linear filters","title":"Discrete correlation","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Call the correlate method as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"dst = correlate(A, B)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to compute the discrete correlation of array A by the kernel defined by B. The result dst is an array similar to A.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Using indices(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete correlation of A by B writes (see Section Discrete convolution and correlation):","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for k ∈ indices(B) ∩ (indices(A) - i)\n        v += A[i+k]*conj(B[k])\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"with T a suitable element type for the result (see Section Element type of the result below) and where indices(B) ∩ (indices(A) - i) denotes the subset of indices k such that k ∈ indices(B) and i + k ∈ indices(A) and thus for which B[k] and A[i+k] are valid.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Following the conventions in localfilter!, the discrete correlation can also be expressed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for j ∈ indices(A) ∩ (indices(B) + i)\n        v += A[j]*conj(B[j-i])\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"If the kernel B is an array of Booleans, the discrete correlation is computed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"for i ∈ indices(A)\n    v = zero(T)\n    @inbounds for j ∈ indices(A) ∩ (indices(B) + i)\n        v += A[j]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which amounts to computing the local sum of the values of A in the neighborhood defined by the true entries of B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The in-place version correlate! may be used to avoid allocations:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"correlate!(dst, A, B)","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which overwrites dst with the discrete correlation of A by the kernel B and returns dst.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"SInce accessing the indices of A and B in the same order is generally faster (e.g. it is easier to optimize via loop vectorization), the discrete convolution convolve(A,B) of A by B may be computed by:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"correlate(A, reverse_kernel(B))","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"provided the entries of B are reals, not complexes.","category":"page"},{"location":"linear/#Element-type-of-the-result","page":"Linear filters","title":"Element type of the result","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Choosing a suitable element type for the result may be tricky if the entries of the source array A and of the kernel B have different types or have units.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"For example, a suitable element type T for the result of the convolution or correlation of A by B is given by:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = let a = oneunit(eltype(A)), b = oneunit(eltype(B)), c = a*b\n    typeof(c + c)\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which is the type of the sum of the element-wise product of the entries of A and B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"For the local mean, a similar reasoning yields:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = let a = oneunit(eltype(A)), b = oneunit(eltype(B)), c = a*b\n    typeof((c + c)/(b + b))\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which is the type of the sum of the element-wise product of the entries of A and B divided by the sum of the entries in B (the so-called weights).","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"These rules are the ones used by the out-of-place versions of the linear filters of LocalFilter when the destination is not provided.","category":"page"},{"location":"nonlinear/#Non-linear-filters","page":"Non-linear filters","title":"Non-linear filters","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"LocalFilters provides a number of non-linear filters such as the bilateral filter and mathematical morphology filters. The latter are described in the Section Non-linear morphological filters.","category":"page"},{"location":"nonlinear/#The-bilateral-filter","page":"Non-linear filters","title":"The bilateral filter","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Applying the bilateral filter on array A writes:","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter([T=float(eltype(A)),] A, F, G, ...)","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Argument F specifies how to smooth the differences in values. It may be function which takes two values from A as arguments and returns a nonnegative weight. It may be a real which is assumed to be the standard deviation of a Gaussian.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Arguments G, ... specify the settings of the distance filter for smoothing differences in coordinates. There are several possibilities:","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"G, ... can be a single argument specifying a kernel (see Section Simple rules for specifying neighborhoods and kernels).\nArgument G may be a function taking as argument the Cartesian index of the coordinate differences and returning a nonnegative weight. Argument G may also be a real specifying the standard deviation of the Gaussian used to compute weights. Subsequent arguments ... are to specify the neighborhood where to apply the distance filter function, they can be anything that may defined a neighborhood (again see Section Simple rules for specifying neighborhoods and kernels). If a standard deviation σ is specified for G with no subsequent arguments, a default window of radius 3σ is assumed.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Optional argument T can be used to force the element type used for (most) computations. This argument is needed if the element type of A is not a real.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter! for an in-place version of this function.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter!([T=float(eltype(A)),] dst, A, F, G, ...) -> dst","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"overwrites dst with the result of applying the bilateral filter on array A and returns dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter for a description of the other arguments than dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See wikipedia for a description of the bilateral filter.","category":"page"},{"location":"morphology/#Non-linear-morphological-filters","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"","category":"section"},{"location":"morphology/#Basic-morphological-operations","page":"Non-linear morphological filters","title":"Basic morphological operations","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Erosion and dilation are the basic operations of mathematical morphology, they are implemented by methods erode and dilate:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode(A, R=3) -> Amin\ndilate(A, R=3) -> Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which respectively return the local minima Amin and the local maxima Amax of argument A in a structuring element defined by R. The notion of structuring element in mathematical morphology is equivalent to that of neighborhood in LocalFilters. The returned result is similar to A (same size and type). If R is not specified, a default hyper-rectangular moving window 3 samples wide in every dimension of A is used. If the structuring element R is a simple hyper-rectangular moving window, the much faster van Herk-Gil-Werman algorithm is used","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The localextrema method combines these two operations in one call:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"localextrema(A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Calling localextrema is usually almost twice as fast as calling erode and dilate.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"To avoid allocating new arrays, the methods erode!, dilate!, and localextrema! provide in-place versions which apply the operation to A with structuring element R and store the result in the provided arrays Amin and/or Amax:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(Amin, A, R=3) -> Amin\ndilate!(Amax, A, R=3) -> Amax\nlocalextrema!(Amin, Amax, A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"If the structuring element R is a simple hyper-rectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(A, R=3) -> A\ndilate!(A, R=3) -> A","category":"page"},{"location":"morphology/#Opening-and-closing-filters","page":"Non-linear morphological filters","title":"Opening and closing filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing(A, R=3)\nopening(A, R=3)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"respectively perform a closing or an opening of array A by the structuring element R. If R is not specified, a default hyper-rectangular moving window of size 3 in every dimension of A is used. A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The in-place versions are:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing!(dst, wrk, A, R=3) -> dst\nopening!(dst, wrk, A, R=3) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which perform the operation on the source A and store the result in destination dst using wrk as a workspace array. The 3 arguments dst, wrk, and A must be similar arrays; dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.","category":"page"},{"location":"morphology/#Top-hat-and-bottom-hat-filters","page":"Non-linear morphological filters","title":"Top-hat and bottom-hat filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods top_hat and bottom_hat perform a summit/valley detection by applying a top-hat filter to an array. They are called as:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(A, R[, S]) -> dst\nbottom_hat(A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"to yield the result of the filter applied to array A. Argument R defines the structuring element for the feature detection. Optional argument S specifies the structuring element for smoothing A prior to the top-/bottom-hat filter. If R and S are specified as the radii of the structuring elements, then S should be smaller than R. For instance:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(bitmap, 3, 1)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"may be used to detect text or lines in a bitmap image.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods LocalFilters.top_hat! and LocalFilters.bottom_hat! implement the in-place versions of these filters:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat!(dst, wrk, A, R[, S]) -> dst\nbottom_hat!(dst, wrk, A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"apply the top-/bottom-hat filter on the source A and store the result in the destination dst using wrk as a workspace array. The 3 arguments dst, wrk, and A must be similar but different arrays. The destination dst is returned.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following summarizes the documentation of types and methods provided by the LocalFilters package. This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Simple-linear-filters","page":"Reference","title":"Simple linear filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"LocalFilters provides a number of shift-invariant linear filters.","category":"page"},{"location":"reference/#LocalFilters.correlate","page":"Reference","title":"LocalFilters.correlate","text":"correlate(A, B=3) -> dst\n\nyields the discrete correlation of the array A by the kernel defined by B. The result dst is an array similar to A.\n\nUsing Idx(A) to denote the set of valid indices for array A and assuming B is an array of numerical values, the discrete convolution of A by B writes:\n\ndst = similar(A, T)\nfor i ∈ Idx(dst)\n    v = zero(T)\n    @inbounds for j ∈ Idx(A) ∩ (i + Idx(B))\n        v += A[j]*B[j-i]\n    end\n    dst[i] = v\nend\n\nwith T the type of the sum of the products of the elements of A and B, and where Idx(A) ∩ (i + Idx(B)) denotes the subset of indices j such that j ∈ Idx(A) and j - i ∈ Idx(B) and thus for which A[j] and B[j-i] are valid.\n\nSee also correlate! and convolve.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.correlate!","page":"Reference","title":"LocalFilters.correlate!","text":"correlate!(dst, A, B) -> dst\n\noverwrites dst with the discrete convolution of A by the kernel B and returns dst.\n\nSee also correlate and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve","page":"Reference","title":"LocalFilters.convolve","text":"convolve(A, B=3)\n\nyields the discrete convolution of array A by the kernel defined by B. The result dst is an array similar to A.\n\nUsing Idx(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes:\n\ndst = similar(A, T)\nfor i ∈ Idx(dst)\n    v = zero(T)\n    @inbounds for j ∈ Idx(A) ∩ (i - Idx(B))\n        v += A[j]*B[i-j]\n    end\n    dst[i] = v\nend\n\nwith T the type of the sum of the products of the elements of A and B, and where Idx(A) ∩ (i - Idx(B)) denotes the subset of indices j such that j ∈ Idx(A) and i - j ∈ Idx(B) and thus for which A[j] and B[i-j] are valid.\n\nSee also convolve! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve!","page":"Reference","title":"LocalFilters.convolve!","text":"convolve!(dst, A, B) -> dst\n\noverwrites dst with the discrete convolution of A by the kernel B and returns dst.\n\nSee also convolve and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmean","page":"Reference","title":"LocalFilters.localmean","text":"localmean([T,] A, B=3; null=zero(T), order=FORWARD_FILTER)\n\nyields the local mean of A in a neighborhood defined by B. The result is an array similar to A. If B is not specified, the neighborhood is a hyper-rectangular sliding window of size 3 in every dimension. Otherwise, B may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as A. If B is a single odd integer (as it is by default), the neighborhood is assumed to be a hyper-rectangular sliding window of size B in every dimension.\n\nOptional argument T is to specify the element type of the result.\n\nKeyword null may be used to specify the value of the result where the sum of the weights in a local neighborhood is zero. By default, null = zero(T).\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nSee also localmean! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmean!","page":"Reference","title":"LocalFilters.localmean!","text":"localmean!(dst, A, B=3; null=zero(eltype(dst)), order=FORWARD_FILTER) -> dst\n\noverwrites dst with the local mean of A in a neighborhood defined by B and returns dst.\n\nKeyword null may be used to specify the value of the result where the sum of the weights in the a neighborhood is zero.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nSee also localmean and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-morphology","page":"Reference","title":"Mathematical morphology","text":"","category":"section"},{"location":"reference/#LocalFilters.erode","page":"Reference","title":"LocalFilters.erode","text":"erode(A, B=3; order=FORWARD_FILTER, slow=false) -> Amin\n\nyields the erosion of A by the structuring element defined by B. The returned result, Amin, is similar to A (same size and type) and its values are the local minima of A in the neighborhood defined by B.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nIf B is not an N-dimensional array, kernel(Dims{N},B) is called to build a kernel with N = ndims(A) the number of dimensions of A.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default) and unless keyword slow is true, the much faster van Herk-Gil-Werman algorithm is used.\n\nAn erosion is one of the most basic operations of mathematical morphology. See erode! for an in-place version of the method, dilate for retrieving the local maxima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.erode!","page":"Reference","title":"LocalFilters.erode!","text":"erode!(Amin, A, B=3; order=FORWARD_FILTER, slow=false) -> Amin\n\noverwrites Amin with the erosion of the array A by the structuring element defined by B and returns Amin.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default) and unless keyword slow is true, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:\n\nerode!(A, B=3; order=FORWARD_FILTER, ) -> A\n\nSee erode for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate","page":"Reference","title":"LocalFilters.dilate","text":"dilate(A, B=3; order=FORWARD_FILTER, slow=false) -> Amax\n\nyields the dilation of A by the structuring element defined by B. The returned result, Amax, is similar to A (same size and type) and its values are the local maxima of A in the neighborhood defined by B.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nIf B is not an N-dimensional array, kernel(Dims{N},B) is called to build a kernel with N = ndims(A) the number of dimensions of A.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default) and unless keyword slow is true, the much faster van Herk-Gil-Werman algorithm is used.\n\nA dilation is one of the most basic operations of mathematical morphology. See dilate! for an in-place version of the method, erode for retrieving the local minima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate!","page":"Reference","title":"LocalFilters.dilate!","text":"dilate!(Amax, A, B=3; order=FORWARD_FILTER, slow=false) -> Amax\n\noverwrites Amax with a dilation of the array A by the structuring element defined by B and returns Amax.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nIf the structuring element B is equivalent to a simple hyper-rectangular sliding window (which is the case by default) and unless keyword slow is true, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, A and Amin can be the same arrays. In that case, the following syntax is allowed:\n\ndilate!(A, B=3; order=FORWARD_FILTER) -> A\n\nSee dilate for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema","page":"Reference","title":"LocalFilters.localextrema","text":"localextrema(A, B=3; order=FORWARD_FILTER) -> Amin, Amax\n\nyields the results of performing an erosion and a dilation of A by the structuring element defined by B in a single pass. Calling this method is usually almost twice as fast as calling erode and dilate.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nSee localextrema! for an in-place version of the method, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema!","page":"Reference","title":"LocalFilters.localextrema!","text":"localextrema!(Amin, Amax, A, B=3; order=FORWARD_FILTER) -> Amin, Amax\n\noverwrites Amin and Amax with, respectively, an erosion and a dilation of the array A by the structuring element defined by B in a single pass.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nSee localextrema for an out-of-place version for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing","page":"Reference","title":"LocalFilters.closing","text":"closing(A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\nyields a closing of array A by the structuring element defined by B. A closing is a dilation followed by an erosion. The result dst is an array similar to A.\n\nSee closing! for an in-place version of the method, opening for a related filter, and erode or dilate for a description of these operations and for the meaning of keywords.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing!","page":"Reference","title":"LocalFilters.closing!","text":"closing!(dst, wrk, A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\noverwrites dst with the result of a closing of A by the structuring element defined by B using wrk as a workspace array. The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.\n\nSee closing for a description of this kind of filter and for the meaning of the arguments and keywords.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening","page":"Reference","title":"LocalFilters.opening","text":"opening(A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\nyields an opening of array A by the structuring element defined by B. An opening is an erosion followed by a dilation. The result dst is an array similar to A.\n\nSee opening! for an in-place version of the method, closing for a related filter, and erode or dilate for a description of these operations and for the meaning of keywords.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening!","page":"Reference","title":"LocalFilters.opening!","text":"opening!(dst, wrk, A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\noverwrites dst with the result of an opening of A by the structuring element defined by B using wrk as a workspace array. The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst. The destination dst is returned.\n\nSee opening for a description of this kind of filter and for the meaning of the arguments and keywords.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat","page":"Reference","title":"LocalFilters.top_hat","text":"top_hat(A, B=3[, C]; order=FORWARD_FILTER, slow=false) -> dst\n\nperforms a summit detection by applying a top-hat filter to array A using the structuring element defined by B for the feature detection. Top-hat filtering is equivalent to:\n\ndst = A .- opening(A, B)\n\nOptional argument C specifies the structuring element for smoothing A prior to top-hat filtering. If B and C are specified as the radii of the structuring elements, then C should be smaller than B. For instance:\n\ntop_hat(bitmap, 3, 1)\n\nmay be used to detect text or lines in a bitmap image.\n\nKeyword order specifies the filter(s) direction(s), FORWARD_FILTER by default. If C is specified, order may be a 2-tuple to specify a first order for B and a second one for C.\n\nSee bottom_hat for a related operation, LocalFilters.top_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat!","page":"Reference","title":"LocalFilters.top_hat!","text":"LocalFilters.top_hat!(dst, wrk, A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\noverwrites dst with the result of a top-hat filter applied to A with structuring element B, and using wrk as a workspace whose contents is not preserved. The arguments A, dst, and wrk must be similar but different arrays. The destination dst is returned.\n\nSee also top_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat","page":"Reference","title":"LocalFilters.bottom_hat","text":"bottom_hat(A, B=3[, C]; order=FORWARD_FILTER, slow=false) -> dst\n\nperforms a valley detection by applying a bottom-hat filter to array A using the structuring element defined by B for the feature detection. Bottom-hat filtering is equivalent to:\n\ndst = closing(A, B) .- A\n\nOptional argument C specifies the structuring element for smoothing A prior to bottom-hat filtering. If B and C are specified as the radii of the structuring elements, then C should be smaller than B.\n\nKeyword order specifies the filter(s) direction(s), FORWARD_FILTER by default. If C is specified, order may be a 2-tuple to specify a first order for B and a second one for C.\n\nSee top_hat for a related operation, LocalFilters.bottom_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat!","page":"Reference","title":"LocalFilters.bottom_hat!","text":"LocalFilters.bottom_hat!(dst, wrk, A, B=3; order=FORWARD_FILTER, slow=false) -> dst\n\noverwrites dst with the result of a bottom-hat filter applied to A with structuring element B and optional smoothing element C. Argument wrk is a workspace array whose contents is not preserved. The arguments A, dst, and wrk must be similar but different arrays. The destination dst is returned.\n\nSee also bottom_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Other-non-linear-filters","page":"Reference","title":"Other non-linear filters","text":"","category":"section"},{"location":"reference/#LocalFilters.bilateralfilter","page":"Reference","title":"LocalFilters.bilateralfilter","text":"bilateralfilter([T = float(eltype(A)),] A, F, G...=3; order = FORWARD_FILTER)\n\nyields the result of applying the bilateral filter on array A.\n\nArgument F specifies how to smooth the differences in values. It can be:\n\na function, say f, which is called as f(A[i],A[j]) to yield a nonnegative weight for i the central index and j the index in a nearby position;\na positive real, say σ, which is assumed to be the standard deviation of a Gaussian.\n\nArguments G, ... specify the settings of the distance filter for smoothing differences in coordinates. There are several possibilities:\n\nG... = wgt an array of nonnegative weights or of Booleans. The axes of wgt must have offsets so that the zero index is part of the indices of wgt.\nG... = f, w with f a function and w any kind of argument that can be used to build a window win specifying the extension of the neighborhood. The value of the distance filter will be max(f(i),0) for all Cartesian index i of win such that win[i] is true. See kernel for the different ways to specify a window.\nG... = σ or , G... = σ, w with σ a positive real assumed to be the standard deviation of a Gaussian function and w any kind of argument that can be used to build a window win specifying the extension of the neighborhood. If w is not specified, a default window of size ±3σ is assumed.\n\nOptional argument T is to specify the element type of the result. This is needed if the default is unsuitable.\n\nSee bilateralfilter! for an in-place version of this function and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bilateralfilter!","page":"Reference","title":"LocalFilters.bilateralfilter!","text":"bilateralfilter!(dst, A, F, G...; order = FORWARD_FILTER) -> dst\n\noverwrites dst with the result of applying the bilateral filter on array A and returns dst.\n\nSee bilateralfilter for a description of the other arguments than dst and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Methods-to-build-local-filters","page":"Reference","title":"Methods to build local filters","text":"","category":"section"},{"location":"reference/#LocalFilters.localfilter","page":"Reference","title":"LocalFilters.localfilter","text":"localfilter([T=eltype(A),] A, B, initial, update, final=identity; kwds...) -> dst\n\nout of place version of localfilter! which is equivalent to:\n\nlocalfilter!(similar(A, T), A, B, initial, update, final=identity; kwds...)\n\nOptional argument T is to specify the element type of the result; by default, T is the element type of A.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localfilter!","page":"Reference","title":"LocalFilters.localfilter!","text":"localfilter!(dst, A, B, initial, update::Function, final::Function=identity;\n             order=FORWARD_FILTER) -> dst\n\noverwrites the destination dst with the result of a local filter applied to the source A, on a relative neighborhood defined by B, and implemented by initial, update, and final. The initial argument may be a function or not. The purpose of these latter arguments is explained by the following pseudo-codes implementing the local filtering. Keyword order specifies the filter direction, FORWARD_FILTER by default.\n\nIf order = FORWARD_FILTER:\n\n@inbounds for i ∈ indices(dst)\n    v = initial isa Function ? initial(A[i]) : initial\n    for j ∈ indices(A) ∩ (indices(B) + i)\n        v = update(v, A[j], B[j-i])\n    end\n    dst[i] = final(v)\nend\n\nelse if order = REVERSE_FILTER:\n\n@inbounds for i ∈ indices(dst)\n    v = initial isa Function ? initial(A[i]) : initial\n    for j ∈ indices(A) ∩ (i - indices(B))\n        v = update(v, A[j], B[i-j])\n    end\n    dst[i] = final(v)\nend\n\nwhere indices(A) denotes the range of indices of any array A while indices(B) + i and i - indices(B) respectively denote the set of indices j such that j - i ∈ indices(B) and i - j ∈ indices(B). In other words, j ∈ indices(A) ∩ (i - indices(B)) means all indices j such that j ∈ indices(A) and i - j ∈ indices(B) so that A[j] and B[i-j] are in-bounds.\n\nIf initial is a function, the initial value of the state variable v in the above pseudo-codes is given by v = initial(A[i]) with i the current index in dst. Hence, in that case, the destination array dst and the source array src must have the same axes.\n\nFor example, implementing a local minimum filter (that is, an erosion), is as simple as:\n\nlocalfilter!(dst, A, B, typemax(eltype(A)),\n             (v,a,b) -> ifelse(b, min(v,a), v))\n\nAs another example, implementing a convolution by B writes:\n\nT = promote_type(eltype(A), eltype(B))\nlocalfilter!(dst, A, B, zero(T), (v,a,b) -> v + a*b)\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmap","page":"Reference","title":"LocalFilters.localmap","text":"localmap(f, [T=eltype(A),] A, B=3; null=zero(T), order=FORWARD_FILTER)\n\nfor each position in A, applies the function f to the values of A extracted from the neighborhood defined by B.\n\nOptional argument T is to specify the element type of the result; by default, T is the element type of A.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nRemarks\n\nThe function f is never called with an empty vector of values. Keyword null may be used to specify the value of the result where the neighborhood is empty. By default, null = zero(T) with T the element type of the result.\nThe vector of values passed to f may be modified by f if needed (for example for faster sorting of the values).\n\nExamples\n\nWith argument f set to minimum or maximum, localmap respectively yields the erosion and the dilation of the input array. However erode and dilate methods are faster until localmap is specialized for these functions.\n\nApplying a median filter of the 2-dimensional image img in a sliding 5×5 window can be done by:\n\nusing Statistics\nmed = localmap(median!, img, 5; eltype=float(eltype(img)), null=NaN)\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmap!","page":"Reference","title":"LocalFilters.localmap!","text":"localmap!(f, dst, A, B=3; null=zero(eltype(dst)), order=FORWARD_FILTER)\n\nset each entry of dst, to the result of applying the function f to the values of A extracted from the neighborhood defined by B.\n\nThe function f is never called with an empty vector of values. Keyword null may be used to specify the value of the result where the neighborhood is empty. By default, null = zero(T) with T the element type of the result.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localreduce","page":"Reference","title":"LocalFilters.localreduce","text":"localreduce(op, [T=eltype(A),] A, dims, rngs; kwds...) -> dst\n\nyields the local reduction by the associative binary operator op of the values of A into contiguous hyper-rectangular neighborhoods defined by the interval(s) rngs along dimension(s) dims of A. The algorithm of van Herk-Gil-Werman is used to compute the reduction.\n\nOptional argument T is to specify the element type of the result.\n\nArgument dims specifies along which dimension(s) of A the local reduction is to be applied, it can be a single integer, a tuple of integers, or a colon : to apply the operation to all dimensions. Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that, if rngs is a single interval, it is used for every dimension in dims). An interval is either an integer or an integer valued unit range in the form kmin:kmax. An interval specified as a single integer is treated as an approximately centered range of this length.\n\nKeyword order specifies the filter direction, FORWARD_FILTER by default.\n\nKeyword work may be used to provide a workspace array of type Vector{T} which is automatically resized as needed.\n\nAssuming a mono-dimensional array A, the single reduction pass:\n\ndst = localreduce(op, A, :, rng)\n\namounts to computing (assuming forward ordering):\n\ndst[j] =  A[i+kmin] ⋄ A[i+kmin+1] ⋄ ... ⋄ A[i+kmax-1] ⋄ A[i+kmax]\n\nfor all j ∈ axes(dst,1), with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng). Note that if kmin = kmax = k, the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0. This can be exploited to not filter some dimension(s).\n\nFlat boundary conditions are assumed for A[i+k] in the above formula.\n\nExamples\n\nThe morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be obtained by:\n\nlocalreduce(min, A, :, -3:3)\n\nor equivalently by:\n\nlocalreduce(min, A, :, 7)\n\nIndex interval 0:0 may be specified to do nothing along the corresponding dimension. For instance, assuming A is a three-dimensional array:\n\nlocalreduce(max, A, :, (-3:3, 0:0, -4:4))\n\nyields the morphological dilation (i.e. local maximum) of A in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension). The same result may be obtained with:\n\nlocalreduce(max, A, (1,3), (-3:3, -4:4))\n\nwhere the second dimension is omitted from the list of dimensions.\n\nThe local average of the two-dimensional array A on a centered sliding window of size 11×11 can be computed as:\n\nlocalreduce(+, A, :, (-5:5, -5:5)) ./ 11^2\n\nSee localreduce! for an in-place version of the method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localreduce!","page":"Reference","title":"LocalFilters.localreduce!","text":"localreduce!(op, [dst = A,] A, dims, rngs; kwds...)\n\noverwrites the contents of dst with the local reduction by the associative binary operator op of the values of A into contiguous hyper-rectangular neighborhoods defined by the interval(s) rngs along dimension(s) dims of A. Except if a single dimension of interest is specified by dims, the destination dst must have the same indices as the source A (that is, axes(dst) == axes(A)). Operation may be done in-place and dst and A can be the same; this is the default behavior if dst is not specified. The algorithm of van Herk-Gil-Werman is used to compute the reduction.\n\nSee localreduce for a full description of the method and for accepted keywords.\n\nThe in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be obtained by:\n\nlocalreduce!(min, A, :, -3:3)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Constants","page":"Reference","title":"Constants","text":"","category":"section"},{"location":"reference/#LocalFilters.FORWARD_FILTER","page":"Reference","title":"LocalFilters.FORWARD_FILTER","text":"FORWARD_FILTER\n\nis an exported constant object used to indicate forward ordering of indices in local filter operations. It can be called as:\n\nFORWARD_FILTER(i, j) -> j - i\n\nto yield the index in the filter kernel. See also REVERSE_FILTER for reverse ordering and LocalFilters.localindices for building a range of valid indices j.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#LocalFilters.REVERSE_FILTER","page":"Reference","title":"LocalFilters.REVERSE_FILTER","text":"REVERSE_FILTER\n\nis an exported constant object used to indicate reverse ordering of indices in local filter operations. It can be called as:\n\nREVERSE_FILTER(i, j) -> i - j\n\nto yield the index in the filter kernel. See also FORWARD_FILTER for forward ordering and LocalFilters.localindices for building a range of valid indices j.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Neighborhoods,-boxes,-kernels,-and-windows","page":"Reference","title":"Neighborhoods, boxes, kernels, and windows","text":"","category":"section"},{"location":"reference/#LocalFilters.kernel","page":"Reference","title":"LocalFilters.kernel","text":"kernel([Dims{N},] args...)\n\nyields an N-dimensional abstract array built from args... and which can be used as a kernel in local filtering operations. The kernel is called a neighborhood, a sliding window, or a structuring element when its element are of type Bool and indicate whether a cell is to be considered. A box is a kernel whose elements are all true, it corresponds to an hyper-rectangular neighborhood whose sides are aligned with the Cartesian axes.\n\nIf args... is composed of N integers and/or ranges or if it is an N-tuple of integers and/or ranges, a box is returned whose axes are specified by args.... Each integer argument is converted in a centered unit range of this length (see LocalFilters.kernel_range).\nIf Dims{N} is provided and args... is a single integer or range, it is interpreted as being the same for all dimensions of an N-dimensional kernel. For example, kernel(Dims{3},5) yields a 3-dimensional box with index range -2:2 in every dimension.\nIf args... is two Cartesian indices or a 2-tuple of Cartesian indices, say start and stop, a box is returned whose first and last indices are start and stop.\nIf args... is a Cartesian range, say R::CartesianIndices{N}, a box array is returned whose axes are given by R.\nIf args... is an abstract array of any other type than CartesianIndices, it is returned unchanged.\n\nOptional leading argument Dims{N} can be specified to assert the number of dimensions of the result or to provide the number of dimensions when it cannot be inferred from the arguments. For example, when args... is a single integer length or range which should be interpreted as being the same for all dimensions.\n\nSee also LocalFilters.strel, LocalFilters.ball, LocalFilters.kernel_range, and LocalFilters.reverse_kernel.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.Kernel","page":"Reference","title":"LocalFilters.Kernel","text":"LocalFilters.Kernel{N}\n\nis the union of types of arguments suitable to define a N-dimensional kernel or filter. Any argument B of this type can be converted into a N-dimensional kernel array by kernel(Dims{N}, B).\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.Window","page":"Reference","title":"LocalFilters.Window","text":"LocalFilters.Window{N}\n\nis the union of types of arguments suitable to define a N-dimensional sliding window that is a N-dimensional array of Booleans indicating whether a position belongs to the window of not. Any argument B of this type can be converted into a N-dimensional array of Booleans by kernel(Dims{N}, B).\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.strel","page":"Reference","title":"LocalFilters.strel","text":"strel(T, A)\n\nyields a structuring element suitable for mathematical morphology operations. The result is an array whose elements have type T (which can be Bool or a floating-point type). Argument A can be a hyper-rectangular Cartesian sliding window or an array with boolean elements.\n\nIf T is a floating-point type, then the result is a so-called flat structuring element whose coefficients are zero(T) inside the shape defined by A and -T(Inf) elsewhere.\n\nSee also LocalFilters.kernel, LocalFilters.box, and LocalFilters.ball.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.ball","page":"Reference","title":"LocalFilters.ball","text":"LocalFilters.ball(Dims{N}, r)\n\nyields a mask approximating a N-dimensional ball of radius r. The result is N-dimensional array of Boolean's with all dimensions odd and equal and whose values are true inside the ball (where distance to the center ≤ r) and false otherwise. The mask may be used to specify the neighborhood, the kernel, or the structuring element in local filtering operations.\n\nThe returned mask has centered axes, to get a mask with 1-based indices, call:\n\nLocalFilters.ball(Dims{N}, r).parent\n\nSee also LocalFilters.kernel and LocalFilters.strel.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.box","page":"Reference","title":"LocalFilters.box","text":"LocalFilters.box(args...) -> B::Box\n\nyields an hyper-rectangular sliding window for local filtering or mathematical morphology operations with the same axes or indices as its argument(s).\n\nSee also LocalFilters.kernel and LocalFilters.strel.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.Box","page":"Reference","title":"LocalFilters.Box","text":"const LocalFilters.Box{N} = FastUniformArray{Bool,N,true}\n\nis an alias to the type of uniformly true N-dimensional arrays. Instances of this kind are used to represent hyper-rectangular sliding windows in LocalFilters.\n\nMethod LocalFilters.box can be used to build an object of this type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.centered","page":"Reference","title":"LocalFilters.centered","text":"LocalFilters.centered(A) -> B\n\nyields an abstract array B sharing the entries of array A but with offsets on indices so that the axes of B are centered (for even dimension lengths, the same conventions as in fftshift are used).\n\nThis public method is purposely not exported because it could introduce some confusions. For example OffsetArrays.centered is similar but has a slightly different semantic.\n\nSee also LocalFilters.kernel_range, LocalFilters.centered_offset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.reverse_kernel","page":"Reference","title":"LocalFilters.reverse_kernel","text":"B = reverse_kernel(args...)\n\nyields a kernel B which is similar to A = kernel(args...) but with reversed ordering in the sense that B[i] == A[-i] holds for all indices i such that -i is a valid index in A. As a consequence, a correlation by B yields the same result as a convolution by A and conversely.\n\nSee also LocalFilters.kernel and LocalFilters.strel.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Below are described non-exported types and methods that may be useful in the context of building local filters.","category":"page"},{"location":"reference/#LocalFilters.Indices","page":"Reference","title":"LocalFilters.Indices","text":"I = LocalFilters.Indices(A::AbstractArray...)\n\nbuilds a callable object, I, that can be used to produce ranges of indices for each of the arrays A.... These ranges will all be of the same type: linear index ranges, if all arrays A... are vectors, Cartesian index ranges otherwise.\n\nI is similar to the eachindex method but is specialized for a style of indexing, it can be called as I(B...) to yield a suitable index range to access all the entries of array(s) B... which are any number of the A... specified when building I. If B... consists in several arrays, they must have the same axes otherwise I(B...) will throw a DimensionMismatch exception.\n\nCall:\n\nI = LocalFilters.Indices{S}()\n\nwith S = IndexLinear or S = IndexCartesian to specifically choose the indexing style.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.localindices","page":"Reference","title":"LocalFilters.localindices","text":"LocalFilters.localindices(A_inds, ord, B_inds, i) -> J\n\nyields the subset J of all indices j such that:\n\nA[j] and B[ord(i,j)] = B[j-i] are in-bounds if ord = FORWARD_FILTER;\nA[j] and B[ord(i,j)] = B[i-j] are in-bounds if ord = REVERSE_FILTER;\n\nwith A and B arrays whose index ranges are given by A_inds and B_inds. To make the code agnostic to the ordering, use A[i] and B[ord(i,j)] to retrieve the values in A and B.\n\nIndex ranges A_inds and B_inds and index i must be of the same kind:\n\nlinear index ranges for A_inds and B_inds and linear index for i;\nCartesian index ranges for A_inds and B_inds and Cartesian index for i of same number of dimensions.\n\nConstructor LocalFilters.Indices may by used to build a callable object that yields the index ranges of A and B in a consistent way:\n\nindices = LocalFilters.Indices(A, B)\nA_inds = indices(A)\nB_inds = indices(B)\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.check_axes","page":"Reference","title":"LocalFilters.check_axes","text":"LocalFilters.check_axes([I,] A...)\n\nthrows an exception if not all arrays A... have the same axes, or all have axes I if specified.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.is_morpho_math_box","page":"Reference","title":"LocalFilters.is_morpho_math_box","text":"LocalFilters.is_morpho_math_box(B)\n\nyields whether structuring element B has the same effect as an hyper-rectangular box for mathematical morphology operations. This may be used to use fast separable versions of mathematical morphology operations like the van Herk-Gil-Werman algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.kernel_range","page":"Reference","title":"LocalFilters.kernel_range","text":"LocalFilters.kernel_range([ord=FORWARD_FILTER,] rng::AbstractRange{<:Integer})\nLocalFilters.kernel_range([ord=FORWARD_FILTER,] len::Integer)\nLocalFilters.kernel_range([ord=FORWARD_FILTER,] start::Integer, stop::Integer)\n\nyield an unit-step Int-valued index range based on range rng, dimension length len, or first and last indices start and stop. In the case of a given dimension length, a centered range of this length is returned (for even lengths, the same conventions as in fftshift are used).\n\nIf ordering ord is specified, the returned range is suitable for this ordering.\n\nSee also LocalFilters.kernel, LocalFilters.centered_offset, and LocalFilters.centered.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.unit_range","page":"Reference","title":"LocalFilters.unit_range","text":"LocalFilters.unit_range(r::Union{AbstractRange{<:Integer},CartesianIndices})\n\nconverts r into an Int-valued unit step index range. r may be a linear or a Cartesian index range. If r is a linear range, the absolute value of its step must be 1.\n\nLocalFilters.unit_range(start::Integer, stop::Integer)\n\nyields the Int-valued unit step range Int(start):Int(stop).\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.centered_offset","page":"Reference","title":"LocalFilters.centered_offset","text":"LocalFilters.centered_offset(len)\n\nyields the index offset along a centered dimension of length len. That is, -div(Int(len)+2,2). For even dimension lengths, this amounts to using the same conventions as in fftshift.\n\nSee LocalFilters.kernel_range and LocalFilters.centered.\n\n\n\n\n\n","category":"function"},{"location":"math/#Convolution,-correlation,-and-Fourier-transform","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"","category":"section"},{"location":"math/#Fourier-transform","page":"Convolution, correlation, and Fourier transform","title":"Fourier transform","text":"","category":"section"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"The continuous Fourier transform of a(x) is defined by:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"hata(u) = int a(x)mathrme^-mathrmi2piuxmathrmdx","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"The inverse Fourier transform of hata(u) then writes:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"a(x) = int hata(u)mathrme^+mathrmi2piuxmathrmdu","category":"page"},{"location":"math/#Convolution-product","page":"Convolution, correlation, and Fourier transform","title":"Convolution product","text":"","category":"section"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"The convolution product of a(x) by b(x) is defined by:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"c(x) = mathrmConv(ab)(x)\n= int a(y)b(x - y)mathrmdy\n= int b(z)a(x - z)mathrmdz","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"with z = x - y. This also shows that the convolution product is symmetrical:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"mathrmConv(ba) = mathrmConv(ab)","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"Taking z = x - y, the Fourier transform of the convolution product can be expanded as follows:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"beginalign*\nhatc(u) = int c(x)mathrme^-mathrmi2piuxmathrmdx\n= iint a(y)b(x - y)mathrme^-mathrmi2piuxmathrmdxmathrmdy\n= iint a(y)b(z)mathrme^-mathrmi2piu(y + z)mathrmdymathrmdz\n= int a(y)mathrme^-mathrmi2piuymathrmdy\n   int b(z)mathrme^-mathrmi2piuzmathrmdz\n= hata(u)hatb(u)\nendalign*","category":"page"},{"location":"math/#Correlation-product","page":"Convolution, correlation, and Fourier transform","title":"Correlation product","text":"","category":"section"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"The correlation product of a(x) by b(x) is defined by:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"r(x) = mathrmCorr(ab)(x)\n= int a(x + y)b^star(y)mathrmdy\n= int b^star(z - x)a(z)mathrmdz","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"where b^star(y) denotes the complex conjugate of b(y) and with z = x + y. From this follows that:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"mathrmCorr(ba)(x) = mathrmCorr(ab)^star(-x)","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"Taking z = x + y, the Fourier transform of the correlation product can be expanded as follows:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"beginalign*\nhatr(u) = int r(x)mathrme^-mathrmi2piuxmathrmdx\n= iint a(x + y)b^star(y)mathrme^-mathrmi2piuxmathrmdxmathrmdy\n= iint a(z)b^star(y)mathrme^-mathrmi2piu(z - y)mathrmdymathrmdz\n= int a(z)mathrme^-mathrmi2piuzmathrmdz\n   left(int b(y)mathrme^-mathrmi2piuymathrmdyright)^star\n= hata(u)hatb^star(u)\nendalign*","category":"page"},{"location":"math/#Discrete-convolution-and-correlation","page":"Convolution, correlation, and Fourier transform","title":"Discrete convolution and correlation","text":"","category":"section"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"Following the continuous definition, the discrete convolution of a by b is given by:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"ci = sum_j ajbi - j = sum_k bkai - k","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"with k = i - j and where the sums are taken for all possible valid indices.","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"Similarly, following the continuous definition, the discrete correlation of a by b is given by:","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"ri = sum_k ai + kb^stark = sum_k b^starj - iaj","category":"page"},{"location":"math/","page":"Convolution, correlation, and Fourier transform","title":"Convolution, correlation, and Fourier transform","text":"with j = i + k and where the sums are taken for all possible valid indices.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The LocalFilters package provides local linear and non-linear filters for Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code of LocalFilters is available on GitHub.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"generic.md\", \"neighborhoods.md\", \"linear.md\", \"nonlinear.md\",\n         \"morphology.md\", \"separable.md\", \"math.md\", \"reference.md\"]","category":"page"},{"location":"generic/#Generic-local-filters","page":"Generic local filters","title":"Generic local filters","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Most filters provided by the LocalFilters package are implemented by the generic in-place method localfilter! or its out-of-place version `localfilter.","category":"page"},{"location":"generic/#The-localfilter!-method","page":"Generic local filters","title":"The localfilter! method","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"A local filtering operation can be performed by calling the localfilter! method:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B, initial, update, final)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where dst is the destination, A is the source, B defines the neighborhood, initial is a function or the initial value of the state variable, update is a function to update the state variable for each entry of the neighborhood, and final is a function to yield the local result of the filter given the final value of the state variable. The localfilter! method returns the destination dst.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The purpose of arguments initial, update, and final is explained by the following pseudo-code implementing the local filtering:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"@inbounds for i ∈ indices(dst)\n    v = initial isa Function ? initial(A[i]) : initial\n    for j ∈ indices(A) ∩ (indices(B) + i)\n        v = update(v, A[j], B[j-i])\n    end\n    dst[i] = final(v)\nend","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where indices(A) denotes the set of indices of A while indices(B) + i denotes the set of indices j such that j - i ∈ indices(B). In other words, j ∈ indices(A) ∩ (indices(B) + i) means all indices j such that j ∈ indices(A) and j - i ∈ indices(B), hence A[j] and B[j-i] are both in-bounds. In localfilter!, indices i and j are Cartesian indices for multi-dimensional arrays, thus indices(A) is the analogous of CartesianIndices(A) in Julia in that case. For vectors, indices i and j are linear indices.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The behavior of the filter is fully determined by the neighborhood B (see Section Neighborhoods, structuring elements, and kernels) and by the other arguments to deal with the state variable v:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"initial may be a function, in which case the state variable is initially given by v = initial(A[i]); otherwise, initial is assumed to be the initial value of the state variable. As a consequence, if initial is a function, dst and A must have the same axes.\nupdate(v, a, b) yields the updated state variable v with a = A[j] and b = B[j-i].\nfinal(v) yields the result of the filter given the state variable v at the end of the loop on the neighborhood. If not specified, final = identity is assumed.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The localfilter! method takes a keyword order to specify the ordering of the filter. By default, order = FORWARD_FILTER which is implemented by the above pseudo-code and which corresponds to a correlation for a shift-invariant linear filter. The other possibility is order = REVERSE_FILTER which corresponds to a convolution for a shift-invariant linear filter and which amounts to:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"@inbounds for i ∈ indices(dst)\n    v = initial isa Function ? initial(A[i]) : initial\n    for j ∈ indices(A) ∩ (i - indices(B))\n        v = update(v, A[j], B[i-j])\n    end\n    dst[i] = final(v)\nend","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"If B is symmetric, in the sense that B[-j] = B[j] for any in-bounds j, both orderings yield the same result but FORWARD_FILTER is generally faster which is why it is used by default.","category":"page"},{"location":"generic/#The-localfilter-method","page":"Generic local filters","title":"The localfilter method","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The localfilter method is similar to localfilter! except that it allocates the destination:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter(A, B, initial, update, final)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"is the same as:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(similar(A), A, B, initial, update, final)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The element type T of the destination can however be specified as the first argument:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter(T, A, B, initial, update, final)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"which is the same as:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(similar(A, T), A, B, initial, update, final)","category":"page"},{"location":"generic/#Examples","page":"Generic local filters","title":"Examples","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Implementing a local minimum filter (that is, an erosion) with localfilter is as simple as:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"res = localfilter(A, B,\n                  #= initial =# typemax(eltype(A)),\n                  #= update  =# (v,a,b) -> min(v,a))","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"This is typically how Basic morphological operations are implemented in LocalFilters. Here B is only used to define the neighborhood, it is usually called a structuring element in this context.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"As another example, implementing a convolution of A by B writes:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"res = localfilter(similar(A), A, B,\n                   #= initial =# zero(eltype(A)),\n                   #= update  =# (v,a,b) -> v + a*b; order = REVERSE_FILTER)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"while:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"dst = localfilter!(similar(A), A, B,\n                   #= initial =# zero(eltype(A)),\n                   #= update  =# (v,a,b) -> v + a*b; order = FORWARD_FILTER)","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"computes a correlation of A by B. The only difference is the order keyword which may be omitted in the latter case as FORWARD_FILTER is the default. In the case of convolutions and correlations, B defines the neighborhood but also the weights, it is usually called a kernel in this context.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Apart from specializations to account for the type of neighborhood defined by B, it is essentially the way the correlate and convolve! methods (described in the Section Linear filters) are implemented in LocalFilters.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"In the above examples, the initial value of the state variable is always the same and directly provided while the default final = identity is assumed. Below is a more involved example to compute the roughness defined by Wilson et al. (in Marine Geodesy 30:3-35, 2007) as the maximum absolute difference between a central cell and surrounding cells:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"function roughness(A::AbstractArray{<:Real}, B=3)\n    initial(a) = (; result = zero(a), center = a)\n    update(v, a, _) = (; result = max(v.result, abs(a - v.center)), center=v.center)\n    final(v) = v.result\n    return localfilter!(similar(A), A, B, initial, update, final)\nend","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"This example has been borrowed from the Geomorphometry package for the analysis of Digital Elevation Models (DEM).","category":"page"}]
}
