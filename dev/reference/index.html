<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · LocalFilters.jl Package</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LocalFilters.jl Package</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../generic/">Generic local filters</a></li><li><a class="tocitem" href="../neighborhoods/">Neighborhoods, structuring elements, and kernels</a></li><li><a class="tocitem" href="../linear/">Linear filters</a></li><li><a class="tocitem" href="../nonlinear/">Non-linear filters</a></li><li><a class="tocitem" href="../morphology/">Non-linear morphological filters</a></li><li><a class="tocitem" href="../separable/">Efficient separable filters for associative operations</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Linear-filters"><span>Linear filters</span></a></li><li><a class="tocitem" href="#Mathematical-morphology"><span>Mathematical morphology</span></a></li><li><a class="tocitem" href="#Other-non-linear-filters"><span>Other non-linear filters</span></a></li><li><a class="tocitem" href="#Generic-driver-for-custom-local-filters"><span>Generic driver for custom local filters</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LocalFilters.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following summarizes the documentation of types and methods provided by the <code>LocalFilters</code> package. This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LocalFilters.ball"><code>LocalFilters.ball</code></a></li><li><a href="#LocalFilters.bilateralfilter"><code>LocalFilters.bilateralfilter</code></a></li><li><a href="#LocalFilters.bilateralfilter!"><code>LocalFilters.bilateralfilter!</code></a></li><li><a href="#LocalFilters.bottom_hat"><code>LocalFilters.bottom_hat</code></a></li><li><a href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a></li><li><a href="#LocalFilters.closing"><code>LocalFilters.closing</code></a></li><li><a href="#LocalFilters.closing!"><code>LocalFilters.closing!</code></a></li><li><a href="#LocalFilters.convolve"><code>LocalFilters.convolve</code></a></li><li><a href="#LocalFilters.convolve!"><code>LocalFilters.convolve!</code></a></li><li><a href="#LocalFilters.dilate"><code>LocalFilters.dilate</code></a></li><li><a href="#LocalFilters.dilate!"><code>LocalFilters.dilate!</code></a></li><li><a href="#LocalFilters.erode"><code>LocalFilters.erode</code></a></li><li><a href="#LocalFilters.erode!"><code>LocalFilters.erode!</code></a></li><li><a href="#LocalFilters.localextrema"><code>LocalFilters.localextrema</code></a></li><li><a href="#LocalFilters.localextrema!"><code>LocalFilters.localextrema!</code></a></li><li><a href="#LocalFilters.localfilter"><code>LocalFilters.localfilter</code></a></li><li><a href="#LocalFilters.localfilter!"><code>LocalFilters.localfilter!</code></a></li><li><a href="#LocalFilters.localmean"><code>LocalFilters.localmean</code></a></li><li><a href="#LocalFilters.localmean!"><code>LocalFilters.localmean!</code></a></li><li><a href="#LocalFilters.opening"><code>LocalFilters.opening</code></a></li><li><a href="#LocalFilters.opening!"><code>LocalFilters.opening!</code></a></li><li><a href="#LocalFilters.strel"><code>LocalFilters.strel</code></a></li><li><a href="#LocalFilters.top_hat"><code>LocalFilters.top_hat</code></a></li><li><a href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a></li></ul><h2 id="Linear-filters"><a class="docs-heading-anchor" href="#Linear-filters">Linear filters</a><a id="Linear-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-filters" title="Permalink"></a></h2><p><code>LocalFilters</code> provides convolutive filters which are shift-invariant linear filters.</p><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localmean" href="#LocalFilters.localmean"><code>LocalFilters.localmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localmean(A, [ord=ForwardFilter,] B=3)</code></pre><p>yields the local mean of <code>A</code> in a neighborhood defined by <code>B</code>. The result is an array similar to <code>A</code>. If <code>B</code> is not specified, the neighborhood is a hyper-rectangular sliding window of size 3 in every dimension. Otherwise, <code>B</code> may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as <code>A</code>. If <code>B</code> is a single odd integer (as it is by default), the neighborhood is assumed to be a hyper-rectangular sliding window of size <code>B</code> in every dimension.</p><p>See also <a href="#LocalFilters.localmean!"><code>localmean!</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/linear.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localmean!" href="#LocalFilters.localmean!"><code>LocalFilters.localmean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localmean!(dst, A, [ord=ForwardFilter,] B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the local mean of <code>A</code> in a neighborhood defined by <code>B</code> and returns <code>dst</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/linear.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.convolve" href="#LocalFilters.convolve"><code>LocalFilters.convolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolve(A, B=3)</code></pre><p>yields the discrete convolution of array <code>A</code> by the kernel defined by <code>B</code>. The result <code>dst</code> is an array similar to <code>A</code>.</p><p>Using <code>Sup(A)</code> to denote the set of valid indices for array <code>A</code> and assuming <code>B</code> is an array of values, the discrete convolution of <code>A</code> by <code>B</code> writes:</p><pre><code class="nohighlight hljs">T = promote_type(eltype(A), eltype(B))
for i ∈ Sup(A)
    v = zero(T)
    @inbounds for j ∈ Sup(B) ∩ (i - Sup(A))
        v += A[i-j]*B[j]
    end
    dst[i] = v
end</code></pre><p>with <code>T</code> the type of the product of elements of <code>A</code> and <code>B</code>, and where <code>Sup(B) ∩ (i - Sup(A))</code> denotes the subset of indices <code>k</code> such that <code>k ∈ Sup(B)</code> and <code>i - k ∈ Sup(A)</code> and thus for which <code>B[k]</code> and <code>A[i-k]</code> are valid.</p><p>See also <a href="#LocalFilters.convolve!"><code>convolve!</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/linear.jl#L147-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.convolve!" href="#LocalFilters.convolve!"><code>LocalFilters.convolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolve!(dst, A, B) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the discrete convolution of <code>A</code> by the kernel <code>B</code> and returns <code>dst</code>.</p><p>See also <a href="#LocalFilters.convolve"><code>convolve</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/linear.jl#L173-L181">source</a></section></article><h2 id="Mathematical-morphology"><a class="docs-heading-anchor" href="#Mathematical-morphology">Mathematical morphology</a><a id="Mathematical-morphology-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-morphology" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.erode" href="#LocalFilters.erode"><code>LocalFilters.erode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode(A, [ord=ForwardFilter,] B=3) -&gt; Amin</code></pre><p>yields the erosion of <code>A</code> by the structuring element defined by <code>B</code>. The erosion is the array of local minima of <code>A</code>. The returned result <code>Amin</code> is similar to <code>A</code> (same size and type).</p><p>If <code>B</code> is not a kernel (that is, if <code>B</code> is not an array or is an instance of <code>CartesianIndices</code>), <a href="@ref"><code>kernel(Dims{N},B)</code></a> is called to build a kernel with <code>N</code> the number of dimensions of <code>A</code>.</p><p>If the structuring element <code>B</code> is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used.</p><p>An erosion is one of the most basic operations of mathematical morphology. See <a href="#LocalFilters.erode!"><code>erode!</code></a> for an in-place version of the method, <a href="#LocalFilters.dilate"><code>dilate</code></a> for retrieving the local maxima, and <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for performing an erosion and a dilation in a single pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L14-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.erode!" href="#LocalFilters.erode!"><code>LocalFilters.erode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode!(Amin, A, [ord=ForwardFilter,] B=3) -&gt; Amin</code></pre><p>overwrites <code>Amin</code> with the erosion of the array <code>A</code> by the structuring element defined by <code>B</code> and returns <code>Amin</code>.</p><p>If the structuring element <code>B</code> is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, <code>A</code> and <code>Amin</code> can be the same arrays. In that case, the following syntax is allowed:</p><pre><code class="nohighlight hljs">erode!(A, [ord=ForwardFilter,] B=3) -&gt; A</code></pre><p>See <a href="#LocalFilters.erode"><code>erode</code></a> for an out-of-place version and for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.dilate" href="#LocalFilters.dilate"><code>LocalFilters.dilate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate(A, [ord=ForwardFilter,] B=3) -&gt; Amax</code></pre><p>yields the dilation of <code>A</code> by the structuring element defined by <code>B</code>. The dilation is the array of local maxima of <code>A</code>. The returned result <code>Amax</code> is similar to <code>A</code> (same size and type).</p><p>If <code>B</code> is not a kernel (that is, if <code>B</code> is not an array or is an instance of <code>CartesianIndices</code>), <a href="@ref"><code>kernel(Dims{N},B)</code></a> is called to build a kernel with <code>N</code> the number of dimensions of <code>A</code>.</p><p>If the structuring element <code>B</code> is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used.</p><p>A dilation is one of the most basic operations of mathematical morphology. See <a href="#LocalFilters.dilate!"><code>dilate!</code></a> for an in-place version of the method, <a href="#LocalFilters.erode"><code>erode</code></a> for retrieving the local minima, and <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for performing an erosion and a dilation in a single pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.dilate!" href="#LocalFilters.dilate!"><code>LocalFilters.dilate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate!(Amax, A, [ord=ForwardFilter,] B=3) -&gt; Amax</code></pre><p>overwrites <code>Amax</code> with a dilation of the array <code>A</code> by the structuring element defined by <code>B</code> and returns <code>Amax</code>.</p><p>If the structuring element <code>B</code> is equivalent to a simple hyper-rectangular sliding window (which is the case by default), the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place. That is, <code>A</code> and <code>Amin</code> can be the same arrays. In that case, the following syntax is allowed:</p><pre><code class="nohighlight hljs">dilate!(A, [ord=ForwardFilter,] B=3) -&gt; A</code></pre><p>See <a href="#LocalFilters.dilate"><code>dilate</code></a> for an out-of-place version and for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L76-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localextrema" href="#LocalFilters.localextrema"><code>LocalFilters.localextrema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localextrema(A, [ord=ForwardFilter,] B=3) -&gt; Amin, Amax</code></pre><p>yields the results of performing an erosion and a dilation of <code>A</code> by the structuring element defined by <code>B</code> in a single pass. Calling this method is usually almost twice as fast as calling <a href="#LocalFilters.erode"><code>erode</code></a> and <a href="#LocalFilters.dilate"><code>dilate</code></a>.</p><p>See <a href="#LocalFilters.localextrema!"><code>localextrema!</code></a> for an in-place version of the method, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L255-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localextrema!" href="#LocalFilters.localextrema!"><code>LocalFilters.localextrema!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localextrema!(Amin, Amax, A, [ord=ForwardFilter,] B=3) -&gt; Amin, Amax</code></pre><p>overwrites <code>Amin</code> and <code>Amax</code> with, respectively, an erosion and a dilation of the array <code>A</code> by the structuring element defined by <code>B</code> in a single pass.</p><p>See <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for an out-of-place version for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L269-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.closing" href="#LocalFilters.closing"><code>LocalFilters.closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing(A, [ord=ForwardFilter,] B=3) -&gt; dst</code></pre><p>yields a closing of array <code>A</code> by the structuring element defined by <code>B</code>. A closing is a dilation followed by an erosion. The result <code>dst</code> is an array similar to <code>A</code>.</p><p>See <a href="#LocalFilters.closing!"><code>closing!</code></a> for an in-place version of the method, <a href="#LocalFilters.opening"><code>opening</code></a> for a related filter, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L356-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.closing!" href="#LocalFilters.closing!"><code>LocalFilters.closing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing!(dst, wrk, A, B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a closing of <code>A</code> by the structuring element defined by <code>B</code> using <code>wrk</code> as a workspace array. The arguments <code>dst</code>, <code>wrk</code>, and <code>A</code> must be similar arrays, <code>dst</code> and <code>A</code> may be identical, but <code>wrk</code> must not be the same array as <code>A</code> or <code>dst</code>. The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.closing"><code>closing</code></a> for a description of this kind of filter and for the meaning of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L369-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.opening" href="#LocalFilters.opening"><code>LocalFilters.opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening(A, B=3) -&gt; dst</code></pre><p>yields an opening of array <code>A</code> by the structuring element defined by <code>B</code>. An opening is an erosion followed by a dilation. The result <code>dst</code> is an array similar to <code>A</code>.</p><p>See <a href="#LocalFilters.opening!"><code>opening!</code></a> for an in-place version of the method, <a href="#LocalFilters.closing"><code>closing</code></a> for a related filter, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L382-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.opening!" href="#LocalFilters.opening!"><code>LocalFilters.opening!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening!(dst, wrk, A, B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of an opening of <code>A</code> by the structuring element defined by <code>B</code> using <code>wrk</code> as a workspace array. The arguments <code>dst</code>, <code>wrk</code>, and <code>A</code> must be similar arrays, <code>dst</code> and <code>A</code> may be identical, but <code>wrk</code> must not be the same array as <code>A</code> or <code>dst</code>. The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.opening"><code>opening</code></a> for a description of this kind of filter and for the meaning of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L395-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.top_hat" href="#LocalFilters.top_hat"><code>LocalFilters.top_hat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">top_hat(A, B=3 [, C]) -&gt; dst</code></pre><p>performs a <em>summit detection</em> by applying a top-hat filter to array <code>A</code> using the structuring element defined by <code>B</code> for the feature detection. Top-hat filtering is equivalent to:</p><pre><code class="nohighlight hljs">dst = A .- opening(A, B)</code></pre><p>Optional argument <code>C</code> specifies the structuring element for smoothing <code>A</code> prior to top-hat filtering. If <code>B</code> and <code>C</code> are specified as the radii of the structuring elements, then <code>C</code> should be smaller than <code>B</code>. For instance:</p><pre><code class="nohighlight hljs">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bitmap image.</p><p>See <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a> for a related operation, <a href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a> for an in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L456-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.top_hat!" href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.top_hat!(dst, wrk, A, [ord=ForwardFilter,] B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a top-hat filter applied to <code>A</code> with structuring element <code>B</code>, and using <code>wrk</code> as a workspace whose contents is not preserved. The arguments <code>A</code>, <code>dst</code>, and <code>wrk</code> must be similar but different arrays. The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.top_hat"><code>top_hat</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L479-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bottom_hat" href="#LocalFilters.bottom_hat"><code>LocalFilters.bottom_hat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bottom_hat(A, B=3 [, C]) -&gt; dst</code></pre><p>performs a <em>valley detection</em> by applying a bottom-hat filter to array <code>A</code> using the structuring element defined by <code>B</code> for the feature detection. Bottom-hat filtering is equivalent to:</p><pre><code class="nohighlight hljs">dst = closing(A, B) .- A</code></pre><p>Optional argument <code>C</code> specifies the structuring element for smoothing <code>A</code> prior to bottom-hat filtering. If <code>B</code> and <code>C</code> are specified as the radii of the structuring elements, then <code>C</code> should be smaller than <code>B</code>.</p><p>See <a href="#LocalFilters.top_hat"><code>top_hat</code></a> for a related operation, <a href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a> for an in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L491-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bottom_hat!" href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.bottom_hat!(dst, wrk, A, B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a bottom-hat filter applied to <code>A</code> with structuring element <code>B</code> and optional smoothing element <code>C</code>. Argument <code>wrk</code> is a workspace array whose contents is not preserved. The arguments <code>A</code>, <code>dst</code>, and <code>wrk</code> must be similar but different arrays. The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/morphology.jl#L509-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.strel" href="#LocalFilters.strel"><code>LocalFilters.strel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel(T, A)</code></pre><p>yields a <em>structuring element</em> suitable for mathematical morphology operations. The result is an array whose elements have type <code>T</code> (which can be <code>Bool</code> or a floating-point type). Argument <code>A</code> can be a hyper-rectangular Cartesian sliding window or an array with boolean elements.</p><p>If <code>T</code> is a floating-point type, then the result is a so-called <em>flat</em> structuring element whose coefficients are <code>zero(T)</code> inside the shape defined by <code>A</code> and <code>-T(Inf)</code> elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/utils.jl#L481-L493">source</a></section></article><h2 id="Other-non-linear-filters"><a class="docs-heading-anchor" href="#Other-non-linear-filters">Other non-linear filters</a><a id="Other-non-linear-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Other-non-linear-filters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bilateralfilter" href="#LocalFilters.bilateralfilter"><code>LocalFilters.bilateralfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bilateralfilter([T=float(eltype(A)),] A, F, [ord=ForwardFilter,] G...=3)</code></pre><p>yields the result of applying the bilateral filter on array <code>A</code>.</p><p>Argument <code>F</code> specifies how to smooth the differences in values. It can be:</p><ul><li><p>a function, say <code>f</code>, which is called as <code>f(A[i],A[j])</code> to yield a nonnegative weight for <code>i</code> the central index and <code>j</code> the index in a nearby position;</p></li><li><p>a positive real, say <code>σ</code>, which is assumed to be the standard deviation of a Gaussian.</p></li></ul><p>Arguments <code>G, ...</code> specify the settings of the distance filter for smoothing differences in coordinates. There are several possibilities:</p><ul><li><p><code>G... = wgt</code> an array of nonnegative weights or of booleans. The axes of <code>wgt</code> must have offsets so that the zero index is part of the indices of <code>wgt</code>.</p></li><li><p><code>G... = f, w</code> with <code>f</code> a function and <code>w</code> any kind of argument that can be used to build a window <code>win</code> specifying the extension of the neighborhood. The value of the distance filter will be <code>max(f(i),0)</code> for all Cartesian index <code>i</code> of <code>win</code> such that <code>win[i]</code> is true. See <a href="@ref"><code>kernel</code></a> for the different ways to specify a window.</p></li><li><p><code>G... = σ</code> or , <code>G... = σ, w</code> with <code>σ</code> a positive real assumed to be the standard deviation of a Gaussian function and <code>w</code> any kind of argument that can be used to build a window <code>win</code> specifying the extension of the neighborhood. If <code>w</code> is not specified, a default window of size <code>±3σ</code> is assumed.</p></li></ul><p>Optional argument <code>T</code> can be used to force the element type of the result. This argument is needed if the element type of <code>A</code> is not a real.</p><p>See <a href="#LocalFilters.bilateralfilter!"><code>bilateralfilter!</code></a> for an in-place version of this function and see <a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia</a> for a description of the bilateral filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/bilateral.jl#L107-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bilateralfilter!" href="#LocalFilters.bilateralfilter!"><code>LocalFilters.bilateralfilter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bilateralfilter!(dst, A, F, [ord=ForwardFilter,] G...) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of applying the bilateral filter on array <code>A</code> and returns <code>dst</code>.</p><p>See <a href="#LocalFilters.bilateralfilter"><code>bilateralfilter</code></a> for a description of the other arguments than <code>dst</code> and see <a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia</a> for a description of the bilateral filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/bilateral.jl#L154-L164">source</a></section></article><h2 id="Generic-driver-for-custom-local-filters"><a class="docs-heading-anchor" href="#Generic-driver-for-custom-local-filters">Generic driver for custom local filters</a><a id="Generic-driver-for-custom-local-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-driver-for-custom-local-filters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localfilter" href="#LocalFilters.localfilter"><code>LocalFilters.localfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localfilter([T=eltype(A),] A, dims, op, [ord=ForwardFilter,]
            rngs[, wrk]) -&gt; dst</code></pre><p>yields the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code>. Optional argument <code>wrk</code> is a workspace array with elements of type <code>T</code> which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as <code>A</code> and it is resized as needed (by calling the <code>resize!</code> method). The optional argument <code>T</code> allows to specify another type of element than <code>eltype(A)</code> for the result.</p><p>Argument <code>dims</code> specifies along which dimension(s) of <code>A</code> the filter is to be applied, it can be a single integer, a tuple of integers, or a colon <code>:</code> to apply the operation to all dimensions. Dimensions are processed in the order given by <code>dims</code> (the same dimension may appear several times) and there must be a matching interval in <code>rngs</code> to specify the structuring element (except that if <code>rngs</code> is a single interval, it is used for every dimension in <code>dims</code>). An interval is either an integer or an integer valued unit range in the form <code>kmin:kmax</code>. An interval specified as a single integer yields an approximately centered range og this length.</p><p>Assuming a mono-dimensional array <code>A</code>, the single filtering pass:</p><pre><code class="nohighlight hljs">dst = localfilter(A, :, op, rng)</code></pre><p>amounts to computing (assuming forward ordering):</p><pre><code class="nohighlight hljs">dst[j] =  A[i+kmin] ⋄ A[i+kmin+1] ⋄ ... ⋄ A[i+kmax-1] ⋄ A[i+kmax]</code></pre><p>for all <code>j ∈ axes(dst,1)</code>, with <code>x ⋄ y = op(x, y)</code>, <code>kmin = first(rng)</code> and <code>kmax = last(rng)</code>. Note that if <code>kmin = kmax = k</code>, the result of the filter is to operate a simple shift by <code>k</code> along the corresponding dimension and has no effects if <code>k = 0</code>. This can be exploited to not filter some dimension(s).</p><p>Flat boundary conditions are assumed for <code>A[i+k]</code> in the above formula.</p><p><strong>Examples</strong></p><p>The <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be obtained by:</p><pre><code class="nohighlight hljs">localfilter(A, :, min, -3:3)</code></pre><p>Index interval <code>0:0</code> may be specified to do nothing along the corresponding dimension. For instance, assuming <code>A</code> is a three-dimensional array:</p><pre><code class="nohighlight hljs">localfilter(A, :, max, (-3:3, 0:0, -4:4))</code></pre><p>yields the <em>morphological dilation</em> (<em>i.e.</em> local maximum) of <code>A</code> in a centered local neighborhood of size <code>7×1×9</code> (nothing is done along the second dimension). The same result may be obtained with:</p><pre><code class="nohighlight hljs">localfilter(A, (1,3), max, (-3:3, -4:4))</code></pre><p>where the second dimension is omitted from the list of dimensions.</p><p>The <em>local average</em> of the two-dimensional array <code>A</code> on a centered moving window of size 11×11 can be computed as:</p><pre><code class="nohighlight hljs">localfilter(A, :, +, (-5:5, -5:5))*(1/11)</code></pre><p>See <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a> for an in-place version of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/separable.jl#L136-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localfilter!" href="#LocalFilters.localfilter!"><code>LocalFilters.localfilter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localfilter!([dst = A,] A, dims, op, [ord=ForwardFilter,] rngs[, wrk])</code></pre><p>overwrites the contents of <code>dst</code> with the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code> and using optional argument <code>wrk</code> as a workspace array. The destination <code>dst</code> must have the same indices as the source <code>A</code> (that is, <code>axes(dst) == axes(A)</code>). Operation may be done in-place and <code>dst</code> and <code>A</code> can be the same; this is the default behavior if <code>dst</code> is not specified.</p><p>See <a href="#LocalFilters.localfilter"><code>localfilter</code></a> for a full description of the method.</p><p>The in-place <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be obtained by:</p><pre><code class="nohighlight hljs">localfilter!(A, :, min, -3:3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/separable.jl#L214-L233">source</a></section><section><div><pre><code class="nohighlight hljs">localfilter!(dst, A, [ord = ForwardFilter,] B, initial, update,
             final = identity) -&gt; dst</code></pre><p>overwrites the destination <code>dst</code> with the result of a local filter applied to the source <code>A</code>, on a relative neighborhood defined by <code>B</code>, and implemented by <code>initial</code>, <code>update</code>, and <code>final</code>. The purpose of these latter arguments is explained by the following pseudo-codes implementing the local filtering. If <code>ord = ForwardFilter</code>:</p><pre><code class="nohighlight hljs">@inbounds for i ∈ indices(dst)
    v = initial
    for j ∈ indices(A) ∩ (indices(B) + i)
        v = update(v, A[j], B[j-i])
    end
    dst[i] = final(v)
end</code></pre><p>else if <code>ord = ReverseFilter</code>:</p><pre><code class="nohighlight hljs">@inbounds for i ∈ indices(dst)
    v = initial
    for j ∈ indices(A) ∩ (i - indices(B))
        v = update(v, A[j], B[i-j])
    end
    dst[i] = final(v)
end</code></pre><p>where <code>indices(A)</code> denotes the range of indices of any array <code>A</code> while <code>indices(B) + i</code> and <code>i - indices(B)</code> respectively denote the set of indices <code>j</code> such that <code>j - i ∈ indices(B)</code> and <code>i - j ∈ indices(B)</code>. In other words, <code>j ∈ indices(A) ∩ (i - indices(B))</code> means all indices <code>j</code> such that <code>j ∈ indices(A)</code> and <code>i - j ∈ indices(B)</code> so that <code>A[j]</code> and <code>B[i-j]</code> are in-bounds.</p><p>For example, implementing a local minimum filter (that is, an <em>erosion</em>), is as simple as:</p><pre><code class="nohighlight hljs">localfilter!(dst, A, ord, B, typemax(eltype(a)), (v,a,b) -&gt; min(v,a))</code></pre><p>As another example, implementing a convolution by <code>B</code> writes:</p><pre><code class="nohighlight hljs">T = promote_type(eltype(A), eltype(B))
localfilter!(dst, A, ord, B, zero(T), (v,a,b) -&gt; v + a*b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/generic.jl#L14-L58">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Neighborhood</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>RectangularBox</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LocalFilters.Kernel</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LocalFilters.ConstantProducer</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LocalFilters.default_start</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.ball" href="#LocalFilters.ball"><code>LocalFilters.ball</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.ball(Dims{N}, r)</code></pre><p>yields a boolean mask which is a <code>N</code>-dimensional array with all dimensions odd and equal and set to true where position is inside a <code>N</code>-dimensional ball of radius <code>r</code>.</p><p>To have a mask with centered index ranges, call:</p><pre><code class="nohighlight hljs">LocalFilters.centered(LocalFilters.ball(Dims{N}, r))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/fa1ff072dd803a61f82e4aed14d5fef49bb13683/src/utils.jl#L519-L530">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../separable/">« Efficient separable filters for associative operations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 7 February 2023 09:59">Tuesday 7 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
